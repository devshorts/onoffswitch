---
layout: post
title: Thinking about haskell functors in .net
date: 2013-09-09 20:06:52.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories: []
tags:
- functors
- haskell
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  _su_rich_snippet_type: none
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1558842116;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:4348;}i:1;a:1:{s:2:"id";i:4725;}i:2;a:1:{s:2:"id";i:4262;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2013/09/09/thinking-haskell-functors-net/"
---
<p>I've been teaching myself haskell lately and came across an interesting language feature called functors. Functors are a way of describing a transformation when you have a boxed container. They have a generic signature of</p>
<p>[fsharp]<br />
('a -&gt; 'b) -&gt; f 'a -&gt; f 'b<br />
[/fsharp]</p>
<p>Where <code>f</code> isn't a "function", it's a type that contains the type of <code>'a</code>.</p>
<p>The idea is you can write custom map functions for types that act as generic containers. Generic containers are things like lists, an option type, or other things that <em>hold</em> something. By itself a <code>list</code> is nothing, it has to be a list OF something.  Not to get sidetracked too much, but these kinds of boxes are called Monads.  </p>
<p>Anyways, let's do this in C# by assuming that we have a box type that holds something.</p>
<p>[csharp]</p>
<p>public class Box&lt;T&gt;<br />
{<br />
    public T Data { get; set; }<br />
}</p>
<p>var boxes = new List&lt;Box&lt;string&gt;&gt;();</p>
<p>IEnumerable&lt;string&gt; boxNames  = boxes.Select(box =&gt; box.Data);</p>
<p>[/csharp]</p>
<p>We have a type <code>Box</code> and a list of <code>boxes</code>.  Then we <code>Select</code> (or map) a box's inner data into another list.  We could extract the projection into a separate function too:</p>
<p>[csharp]<br />
public string BoxString(Box&lt;string&gt; p)<br />
{<br />
    return p.Data;<br />
}<br />
[/csharp]</p>
<p>The type signature of this function is </p>
<p>[csharp]<br />
Box-&gt; string<br />
[/csharp]</p>
<p>But wouldn't it be nice to be able to do work on a boxes data without having to explicity project it out?  Like, maybe define a way so that if you pass in a box, and a function that works on a string, it'll automatically unbox the data and apply the function to its data. </p>
<p>For example something like this (but this won't compile obviously)</p>
<p>[csharp]<br />
public String AddExclamation(String input){<br />
   return input + &quot;!&quot;;<br />
}</p>
<p>IEnumerable&lt;Box&lt;string&gt;&gt; boxes = new List&lt;Box&lt;string&gt;&gt;();</p>
<p>IEnumerable&lt;string&gt; boxStringsExclamation = boxes.Select(AddExclamation);<br />
[/csharp]</p>
<p>In C# we have to add the projection step (which in this case is overloaded):</p>
<p>[csharp]<br />
public String AddExclamation(Box&lt;String&gt; p){<br />
   return AddExclamation(p.Data);<br />
}<br />
[/csharp]</p>
<p>In F# you have to do basically the same thing:</p>
<p>[fsharp]<br />
type Box&lt;'T&gt; = { Data: 'T }</p>
<p>let boxes = List.init 10 (fun i -&gt; { Data= i.ToString() })</p>
<p>let boxStrings = List.map (fun i -&gt; i.Data) boxes<br />
[/fsharp]</p>
<p>But in Haskell, you can define this projection as part of the type by saying it is an instance of the <code>Functor</code> type class.  When you make a generic type an instance of the functor type class you can define how maps work on the insides of that class.  </p>
<p>[fsharp]<br />
data Box a = Data a deriving (Show)</p>
<p>instance Functor Box where<br />
    fmap f (Data inside) = Data(f inside)    </p>
<p>main =<br />
    print $ fmap (++&quot;... your name!&quot;) (Data &quot;my name&quot;)<br />
[/fsharp]</p>
<p>This outputs</p>
<p>[code]<br />
Data &quot;my name... your name!&quot;<br />
[/code]</p>
<p>Here I have a box that contains a value, and it has a value.  Then I can define how a box behaves when someone maps over it. As long as the type of the box contents matches the type of the projection, the call to <code>fmap</code> works.   </p>
