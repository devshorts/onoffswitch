---
layout: post
title: Implementing the game "Arithmetic"
date: 2013-08-24 17:52:55.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- arithmetic
- ast
- expression tree
- F#
- reddit
meta:
  _edit_last: '1'
  _su_rich_snippet_type: none
  _syntaxhighlighter_encoded: '1'
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1560829492;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:2020;}i:1;a:1:{s:2:"id";i:4244;}i:2;a:1:{s:2:"id";i:4262;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2013/08/24/implementing-game-arithmetic/"
---
<p>There is a subreddit on reddit called <a href="http://www.reddit.com/r/dailyprogrammer" target="_blank" rel="noopener noreferrer">/r/dailyprogrammer</a> and while they don't actually post exercises daily, they do sometimes post neat questions that are fun to solve.  About a week ago, they posted <a href="http://www.reddit.com/r/dailyprogrammer/comments/1k7s7p/081313_challenge_135_easy_arithmetic_equations/" target="_blank" rel="noopener noreferrer">a problem</a> that I solved with F# that I wanted to share.  For the impatient, my full source is available at <a href="http://fssnip.net/jy" target="_blank" rel="noopener noreferrer">this fssnip</a>.</p>
<p>The description is as follows:</p>
<blockquote><p>Unix[2] , the famous multitasking and multi-user operating system, has several standards that defines Unix commands, system calls, subroutines, files, etc. Specifically within Version 7[3] (though this is included in many other Unix standards), there is a game called "arithmetic". To quote the Man Page[4] :</p>
<p>Arithmetic types out simple arithmetic problems, and waits for an answer to be typed in. If the answer<br />
is correct, it types back "Right!", and a new problem. If the answer is wrong, it replies "What?", and<br />
waits for another answer. Every twenty problems, it publishes statistics on correctness and the time<br />
required to answer.</p>
<p>Your goal is to implement this game, with some slight changes, to make this an [Easy]-level challenge. You will only have to use three arithmetic operators (addition, subtraction, multiplication) with four integers. An example equation you are to generate is "2 x 4 + 2 - 5".<br />
Author: nint22</p></blockquote>
<h2>The cheating solution</h2>
<p>The cheating solution is to use a dynamic string evaluator. For example, dynamic languages such as ruby, python, and javascript have an <code>eval</code> function where you can pass a string to it and it will give you the result of the evaluation.  That's no fun and I think that defeats the purpose of the exercise. Someone, somewhere, had to actually write what the eval function does.</p>
<p>However, I did leverage a .NET version of the dynamic evaluation (via the <code>DataTable</code> class) to validate my solution in a unit test.</p>
<h2>The F# solution</h2>
<p>Whenever I see arbitrary boundaries, I tend to ignore them. My solution works for any size of expression, so unlike some of the other entries that did a lot of specific handling for only four integers, I tested mine up to 1000 terms.   The basic principle is my solution generates an expression tree to represent the random expression. To evaluate the expression AST, it evaluates portions of the tree based on a defined set of order of operations.  In this way you can partially apply an operation and get a new tree if you want.  When evaluating, you have to deal with the fact that some operations have the same weight, such as <code>+</code> and <code>-</code> so they are evaluated left to right.   </p>
<h2>The data types</h2>
<p>First, the data types:</p>
<p>[fsharp]<br />
type Operation =<br />
    | Mult<br />
    | Sub<br />
    | Add<br />
    override this.ToString() =<br />
        match this with<br />
            | Mult -&gt; &quot;*&quot;<br />
            | Sub -&gt; &quot;-&quot;<br />
            | Add -&gt; &quot;+&quot;<br />
    member this.evaluate =<br />
        match this with<br />
            | Mult -&gt; (*)<br />
            | Sub -&gt; (-)<br />
            | Add -&gt; (+)</p>
<p>let orderofOps = [[Mult];[Add;Sub]]<br />
[/fsharp]</p>
<p>I've created a union type defining the available operations, how to print them out, and what their actual evaluated operation is.  The nice thing in F# is that functions are first class. For example, returning <code>(*)</code> returns a function of signature <code>int -> int -> int</code>.  </p>
<p>Also I've defined an order of operations list list.  Items in inner lists have the same operation precedence (Add and Sub), and the outer list defines what has to happen first.  This way multiplication is evaluated first, then addition and subtraction gets evaluated left to right.</p>
<p>Next is the expression definition. Anyone who's ever worked with syntax tree's should recognize this union pattern:</p>
<p>[fsharp]<br />
type Expression =<br />
    | Terminal of int<br />
    | Expr of Expression * Operation * Expression</p>
<p>[/fsharp]</p>
<p>Since it's the idiomatic form of an expression tree. </p>
<h2>Random expressions and numbers</h2>
<p>Lets generate some randomness. This defines random numbers and random operations.</p>
<p>[fsharp]<br />
let rand = new System.Random()</p>
<p>let randNum min max = rand.Next(min, max)</p>
<p>let randomOperation () =<br />
    match randNum 0 2 with<br />
    | 0 -&gt; Mult<br />
    | 1 -&gt; Sub<br />
    | _ -&gt; Add<br />
[/fsharp]</p>
<p>Now I can generate a random expression, where each term is within a min and max range, and the expression is of a passed in length</p>
<p>[fsharp]<br />
let rec randomExpression min max length =<br />
    match length with<br />
        | 0 -&gt; Terminal(randNum min max)<br />
        | _ -&gt; Expr(Terminal(randNum min max), randomOperation(), randomExpression min max (length - 1))</p>
<p>[/fsharp]</p>
<h2>Display an expression</h2>
<p>It'd also be useful to pretty print our expression</p>
<p>[fsharp]<br />
let rec display = function<br />
        | Terminal(i) -&gt; i.ToString()<br />
        | Expr(left, op, right) -&gt;<br />
             String.Format(&quot;{0} {1} {2}&quot;, display left, op, display right)<br />
[/fsharp]</p>
<p>This outputs an expression printed like</p>
<p>[code]<br />
8 - 6 * 8 - 5 * 9 * 9<br />
[/code]</p>
<h2>Tree Evaluation</h2>
<p>The last thing we need to do is actually evaluate the tree.  Let's break down some of the work into active patterns. I love using active patterns to help hide away complex match statements.</p>
<p>[fsharp]<br />
let (|TermWithExpression|_|) predicate expr  =<br />
       match expr with<br />
        | Expr(Terminal(left), targetOp, Expr(Terminal(right), o, next))<br />
            when predicate targetOp -&gt;<br />
               Expr(Terminal(targetOp.evaluate left right), o, next) |&gt; Some<br />
        | _ -&gt; None<br />
[/fsharp]</p>
<p>If the operator passes a predicate and folds the left and right terms into a new terminal if the expression has a left terminal and a right expression. Something of the form:</p>
<p>[fsharp]<br />
Expr(Terminal(2), Mult, Expr(Terminal(3), Add, Terminal(4)))<br />
[/fsharp]</p>
<p>The next thing is if we have an expression that is composed of just two terminals. </p>
<p>[fsharp]<br />
Expr(Terminal(6), Add, Terminal(4))<br />
[/fsharp]</p>
<p>Again, if the operator passes a predicate we'll fold the two terminals into a new terminal.</p>
<p>[fsharp]<br />
let (|TermWithTerm|_|) predicate expr =<br />
    match expr with<br />
        | Expr(Terminal(item), targetOp, Terminal(item2))<br />
                when predicate targetOp -&gt;<br />
                    Terminal(targetOp.evaluate item item2) |&gt; Some<br />
        | _ -&gt; None<br />
[/fsharp]</p>
<p>Finally, lets tie it all into one function</p>
<p>[fsharp]<br />
let foldExpr expr opsInPrecedence =<br />
    let rec foldExpr' expr =<br />
        let shouldEvalOperator o = List.exists (fun i -&gt; i = o) opsInPrecedence</p>
<p>        match expr with<br />
            | TermWithExpression shouldEvalOperator output -&gt; foldExpr' output<br />
            | TermWithTerm shouldEvalOperator output -&gt; output<br />
            | Expr(left, o, right) -&gt; Expr(foldExpr' left, o, foldExpr' right)<br />
            | Terminal(i) -&gt; Terminal(i)</p>
<p>    foldExpr' expr<br />
[/fsharp]</p>
<h2>Testing it</h2>
<p>I heard a great quote from <a href="http://anton.kovalyov.net/about/" target="_blank" rel="noopener noreferrer">Anton Kovalyov</a>, creator of <a href="http://www.jshint.com/" target="_blank" rel="noopener noreferrer">JSHint</a>, at <a href="https://qconnewyork.com/" target="_blank" rel="noopener noreferrer">QConn NYC</a> 2013: "<em>if it's not tested, it's broken</em>", so here is a test to validate the code:</p>
<p>[fsharp]<br />
[&lt;Test&gt;]<br />
let arithmeticTest() =</p>
<p>    let dt = new DataTable()    </p>
<p>    for i in [0..100] do<br />
        let randomExpr = randomExpression 0 10 5</p>
<p>        let validationResult = dt.Compute(display randomExpr, &quot;&quot;).ToString() |&gt; Convert.ToInt32</p>
<p>        let result = eval randomExpr</p>
<p>        printfn &quot;%s = %d = %d&quot; (display randomExpr) validationResult (match result with Terminal(x) -&gt; x)</p>
<p>        result |&gt; should equal &lt;| Terminal(validationResult)<br />
[/fsharp]</p>
<p>This code uses the evaluate capability of the .NET database (found via this <a href="http://stackoverflow.com/questions/333737/c-sharp-evaluating-string-342-yield-int-18" target="_blank" rel="noopener noreferrer">stackoverflow</a> post) to evaluate the displayed random expression and compare the result to my evaluation of the expression.  </p>
<h2>Division</h2>
<p>In the original problem description, division was left out to avoid having to deal with divide by zero, but I think that would be pretty easy to handle.  The expression folding can know if the right hand term is a zero and the operator is a division, and in that case it can return a <code>None</code> solution. So the folding should be modified to return an expression Option type. </p>
