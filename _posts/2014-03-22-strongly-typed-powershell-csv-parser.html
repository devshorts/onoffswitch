---
layout: post
title: Strongly typed powershell csv parser
date: 2014-03-22 20:25:42.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- bytecode
- csv
- F#
- powershell
- reflection
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  _su_rich_snippet_type: none
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1560310780;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:4598;}i:1;a:1:{s:2:"id";i:4529;}i:2;a:1:{s:2:"id";i:4213;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2014/03/22/strongly-typed-powershell-csv-parser/"
---
<p>Somehow I missed the powershell boat. I've been a .NET developer for years and I trudged through using the boring old cmd terminal, frequently mumbling about how much I missed zsh. But something snapped and I decided to really dive into powershell and learn why those who use it really love the hell out of it.  After realizing that the reason everyone loves it is because everything is strongly typed and you can use .NET in your shell I was totally sold.  </p>
<p>My first forays into powershell included customizing the shell environment. First I got <a href="https://code.google.com/p/conemu-maximus5/" target="_blank" rel="noopener noreferrer">conemu</a> and made it look nice and pretty. Next was to get an ls highlighting module, since I love that about unix shells.</p>
<p>I set up a few fun aliases in <a href="https://github.com/devshorts/powershell_scripts" target="_blank" rel="noopener noreferrer">my profile</a> and felt ready to conquer the world! My next experiment was to try and create an actual binary cmdlet.  I figured, what better way than to create a csv reader.  Now, I realize there is already an <code>Import-Csv</code> cmdlet that types your code, but I figured I'd write one from scratch, since apparently that's what I tend to do (instead of inventing anything new).</p>
<p>My hope was to make it so that it would emit strongly typed objects (which it does), but forwarning, you don't get intellisense on it in the shell.  This is due to the fact that types are generated at runtime and not compile time.  </p>
<p>For the lazy, here is a link to the <a href="https://github.com/devshorts/Playground/tree/master/PowerShellCmdlets/Csv" target="_blank" rel="noopener noreferrer">github</a>.</p>
<h2>The Plan</h2>
<p>At first I thought I'd just wrap the F# csv type provider, but I realized that the type provider needs a template to generate its internal data classes. That won't do here because the cmdlet needs to accept any arbitrary csv file and strongly type at runtime.</p>
<p>To solve that, I figured I could leverage the <a href="http://fsharp.github.io/FSharp.Data/library/CsvFile.html" target="_blank" rel="noopener noreferrer">F# data csv library</a> which would do the actual csv parsing, and then emit runtime bytecode to create data classes representing the header values.</p>
<p>As emitting bytecode is a pain in the ass, I wanted to keep my data classes simple.  If I had a csv like:</p>
<p>[code]<br />
Name,Age,Title<br />
Anton,30,Sr Engineer<br />
Faisal,30,Sr Engineer<br />
[/code]</p>
<p>Then I wanted to emit a class like</p>
<p>[csharp]<br />
public class Whatever{<br />
    public String Name;<br />
    public String Age;<br />
    public String Title;</p>
<p>    public Whatever(String name, String age, String title){<br />
       Name = name;<br />
       Age = age;<br />
       Title = title;<br />
    }<br />
}<br />
[/csharp]</p>
<p>Since that would be the bare minimum that powershell would need to display the type.  </p>
<h2>Emitting bytecode</h2>
<p>First, lets look at the final result of what we need.  The best way to do this is to create a sample type in an assembly and then to use <code>Ildasm</code> (an IL disassembler) to view the bytecode. For example, the following class</p>
<p>[csharp]<br />
using System;</p>
<p>namespace Sample<br />
{<br />
    public class Class1<br />
    {<br />
        public String foo;<br />
        public String bar;</p>
<p>        public Class1(String f, String b)<br />
        {<br />
            foo = f;<br />
            bar = b;<br />
        }<br />
    }<br />
}<br />
[/csharp]</p>
<p>Decompiles into this:</p>
<p>[code]<br />
.method public hidebysig specialname rtspecialname<br />
        instance void  .ctor(string f,<br />
                             string b) cil managed<br />
{<br />
  // Code size       24 (0x18)<br />
  .maxstack  8<br />
  IL_0000:  ldarg.0<br />
  IL_0001:  call       instance void [mscorlib]System.Object::.ctor()<br />
  IL_0006:  nop<br />
  IL_0007:  nop<br />
  IL_0008:  ldarg.0<br />
  IL_0009:  ldarg.1<br />
  IL_000a:  stfld      string Sample.Class1::foo<br />
  IL_000f:  ldarg.0<br />
  IL_0010:  ldarg.2<br />
  IL_0011:  stfld      string Sample.Class1::bar<br />
  IL_0016:  nop<br />
  IL_0017:  ret<br />
} // end of method Class1::.ctor<br />
[/code]</p>
<p>While I didn't just divine how to write bytecode by looking at the IL (I followed some other blog posts), when I got an "invalid bytecode" CLR runtime error, it was nice to be able to compare what I was emitting which what I expected to emit. This way simple errors (like forgetting to load something on the stack) became pretty apparent.</p>
<p>To emit the proper bytecode, we need a few boilerplate items: an assembly, a type builder, an assembly builder, a module builder, and a field builder.  These are responsible for the metadata you need to finally emit your built type.</p>
<p>[fsharp]<br />
let private assemblyName = new AssemblyName(&quot;Dynamics&quot;)</p>
<p>let private assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave)</p>
<p>let private moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName.Name, assemblyName.Name + &quot;.dll&quot;)</p>
<p>let private typeBuilder typeName = moduleBuilder.DefineType(typeName, TypeAttributes.Public)</p>
<p>let private fieldBuilder (typeBuilder:TypeBuilder) name fieldType : FieldBuilder =<br />
    typeBuilder.DefineField(name, fieldType, FieldAttributes.Public)</p>
<p>let private createConstructor (typeBuilder:TypeBuilder) typeList =<br />
    typeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, typeList |&gt; List.toArray)</p>
<p>[/fsharp]</p>
<p>None of this is really all that interesting and hopefully is self explanatory. </p>
<p>The <code>fieldBuilder</code> is important since that will let us declare our local fields.  In fact, once we've declared our local fields using the builder, the only bytecode we have to emit is the constructor (which accepts arguments and instantiates fields in them).</p>
<p>Here is the necessary code to build such a constructor.  </p>
<p>[fsharp]<br />
let private callDefaultConstructor (gen: ILGenerator) =<br />
    let objType = typeof&lt;obj&gt;<br />
    gen.Emit(OpCodes.Call, objType.GetConstructor(Type.EmptyTypes))<br />
    gen.Emit(OpCodes.Ldarg_0)</p>
<p>let private loadThis (gen: ILGenerator) =<br />
    gen.Emit(OpCodes.Ldarg_0)<br />
    gen</p>
<p>let private emitNewInstanceRef (gen : ILGenerator) =<br />
    gen |&gt; loadThis |&gt; callDefaultConstructor</p>
<p>let private assignField (argIndex : int) (field : FieldBuilder) (gen : ILGenerator) =<br />
    gen.Emit(OpCodes.Ldarg, argIndex)<br />
    gen.Emit(OpCodes.Stfld, field)<br />
    gen</p>
<p>let private loadConstructorArg (gen : ILGenerator) ((num, field) : int * FieldBuilder) =<br />
    gen |&gt; loadThis |&gt; assignField num field</p>
<p>let private completeConsructor (gen : ILGenerator) = gen.Emit(OpCodes.Ret)</p>
<p>let private build (fields : FieldBuilder list) (cons : ConstructorBuilder) =<br />
    let generator = cons.GetILGenerator()</p>
<p>    generator |&gt; emitNewInstanceRef</p>
<p>    let fieldsWithIndexes = fields |&gt; List.zip [1..(List.length fields)]</p>
<p>    fieldsWithIndexes<br />
        |&gt; List.map (loadConstructorArg generator)<br />
        |&gt; ignore</p>
<p>    generator |&gt; completeConsructor<br />
[/fsharp]</p>
<p>A few points of interest. </p>
<ul>
<li>Calls that make reference to OpCodes.Ldarp_0 are loading the "this" object to work on. </li>
<li>OpCodes.Stdfld sets the passed in field to the value previously pushed on the stack.</li>
<li>Opcodes.Ldarg with the index passed to it is a dynamic way of saying "load argument X onto the stack"</li>
</ul>
<p>The final piece of the block is to tie it all together. Create field instances, take the target types and create a constructor, then return the type.</p>
<p>[fsharp]<br />
type FieldName = string<br />
type TypeName = string</p>
<p>let make (name : TypeName) (types : (FieldName * Type) list)=<br />
    let typeBuilder = typeBuilder name<br />
    let fieldBuilder = fieldBuilder typeBuilder<br />
    let createConstructor = createConstructor typeBuilder<br />
    let fields = types |&gt; List.map (fun (name, ``type``) -&gt; fieldBuilder name ``type``)<br />
    let definedConstructor = types |&gt; List.map snd |&gt; createConstructor</p>
<p>    definedConstructor |&gt; build fields</p>
<p>    typeBuilder.CreateType()<br />
[/fsharp]</p>
<h2>Instantiating your type</h2>
<p>Lets say we have a record that describes a field, its type, and a target value</p>
<p>[fsharp]<br />
type DynamicField = {<br />
    Name : String;<br />
    Type : Type;<br />
    Value: obj;<br />
}<br />
[/fsharp]</p>
<p>Then we can easily instantiate a target type with</p>
<p>[fsharp]<br />
let instantiate (typeName : TypeName) (objInfo : DynamicField list) =<br />
    let values = objInfo |&gt; List.map (fun i -&gt; i.Value) |&gt; List.toArray<br />
    let types  = objInfo |&gt; List.map (fun i -&gt; (i.Name, i.Type))</p>
<p>    let t = make typeName types</p>
<p>    Activator.CreateInstance(t, values)<br />
[/fsharp]</p>
<p>It's important to note that <code>values</code> is an <code>obj []</code>.  Because its an object array we can pass it to the activates overloaded function that wants a <code>params obj[]</code> and so it'll treat each object in the object array as another argument to the constructor.</p>
<h2>Dynamic static typing of CSV's</h2>
<p>Since there is a way to dynamically create classes at runtime, it should be easy for us to leverage this to do the csv strong typing. In fact, the entire reader is this and emits to you a list of strongly typed entries:</p>
<p>[fsharp]<br />
open System<br />
open System.Reflection<br />
open System.IO<br />
open DataEmitter<br />
open FSharp.Data.Csv</p>
<p>module CsvReader =<br />
    let rand = System.Random()</p>
<p>    let randomName() = rand.Next (0, 999999) |&gt; string</p>
<p>    let defaultHeaders size = [0..size] |&gt; List.map (fun i -&gt; &quot;Unknown Header &quot; + (string i))</p>
<p>    let load (stream : Stream) =<br />
        let csv = CsvFile.Load(stream).Cache()</p>
<p>        let headers = match csv.Headers with<br />
                        | Some(h) -&gt; h |&gt; Array.toList<br />
                        | None -&gt; csv.NumberOfColumns |&gt; defaultHeaders</p>
<p>        let fields = headers |&gt; List.map (fun fieldName -&gt; (fieldName, typeof&lt;string&gt;))</p>
<p>        let typeData = make (randomName()) fields</p>
<p>        [<br />
            for item in csv.Data do<br />
                let paramsArr = item.Columns |&gt; Array.map (fun i -&gt; i :&gt; obj)<br />
                yield Activator.CreateInstance(typeData, paramsArr)<br />
        ]<br />
[/fsharp]</p>
<p>The <code>randomName()</code> is a silly workaround to make sure I don't create the same <code>Type</code> in an assembly.  Each time you run the csv reader it'll create a new random type representing that csv's data. I could maybe have optimized this that if someone calls in for a type with the same list of headers that another type had then to re-use that type instead of creating a duplicate, oh well.</p>
<h2>Using the reader from the cmdlet</h2>
<p>Like I mentioned in the beginning, there is a major flaw here.  The issue is that since my types are generated at runtime (which was really fun to do), it doesn't help me at all.  Cmdlet's need to expose their output types via an <code>OutputType</code> attribute, and since its an attribute I can't expose the type dynamically.</p>
<p>Either way, here is the entire csv cmdlet</p>
<p>[fsharp]<br />
namespace CsvHandler</p>
<p>open DataEmitter<br />
open System.Management.Automation<br />
open System.Reflection<br />
open System<br />
open System.IO</p>
<p>[&lt;Cmdlet(&quot;Read&quot;, &quot;Csv&quot;)&gt;]<br />
type CsvParser() =<br />
    inherit PSCmdlet()</p>
<p>    [&lt;Parameter(Position = 0)&gt;]<br />
    member val File : string = null with get, set</p>
<p>    override this.ProcessRecord() =<br />
        let (fileNames, _) = this.GetResolvedProviderPathFromPSPath this.File</p>
<p>        for file in fileNames do<br />
            use fileStream = File.OpenRead file</p>
<p>            fileStream<br />
                |&gt; CsvReader.load<br />
                |&gt; List.toArray<br />
                |&gt; this.WriteObject<br />
[/fsharp]</p>
<p>This reads an implicit file name (or file with wildcards) and leverages the inherited <code>PsCmdlet</code> class to resolve the path from the passed in file (or expand any splat'd files like <code>some*</code>).  All we do now is pass each file stream to the reader, convert to an array, and pass it to the next item in the powershell pipe.</p>
<h2>See it in action</h2>
<p>Maybe this whole exercise was overkill, but let's finish it out anyways. Let's say we have a csv like this:</p>
<p>[code]<br />
Year,Make,Model,Description,Price<br />
1997,Ford,E350,&quot;ac, abs, moon&quot;,3000.00<br />
1999,Chevy,&quot;Venture &quot;&quot;Extended Edition&quot;&quot;&quot;,&quot;&quot;,4900.00<br />
1999,Chevy,&quot;Venture &quot;&quot;Extended Edition, Very Large&quot;&quot;&quot;,,5000.00<br />
1996,Jeep,Grand Cherokee,&quot;MUST SELL!<br />
air, moon roof, loaded&quot;,4799.00<br />
[/code]</p>
<p>We can do the following</p>
<p><img src="http://onoffswitch.net/wp-content/uploads/2014/03/output1.png" alt="output1" width="996" height="577" class="aligncenter size-full wp-image-4466" /></p>
<p>And filter on items</p>
<p><img src="http://onoffswitch.net/wp-content/uploads/2014/03/filter.png" alt="filter" width="1045" height="138" class="aligncenter size-full wp-image-4467" /></p>
<h2>Cleanup</h2>
<p>After getting draft one done, I thought about the handling of the IL generator in the Data Emitter. There are two things I wanted to accomplish:</p>
<p>1. Clean up having to seed the generator reference to all the functions<br />
2. Clean up passing an auto incremented index to the field initializer</p>
<p>After some mulling I realized that implementing a computation expression to handle the seeded state would be perfect for both scenarios.  We can create an IlBuilder computation expression that will hold onto the reference of the generator and pass it to any function that uses <code>do!</code> syntax.  We can do the same for the auto incremented index with a different builder. Let me show you the final result and then the builders:</p>
<p>[fsharp]<br />
let private build (fields : FieldBuilder list) (cons : ConstructorBuilder) =<br />
    let generator = cons.GetILGenerator()</p>
<p>    let ilBuilder = new ILGenBuilder(generator)</p>
<p>    let forNextIndex = new IncrementingCounterBuilder()</p>
<p>    ilBuilder {<br />
        do! loadThis<br />
        do! callDefaultConstructor<br />
        do! loadThis</p>
<p>        for field in fields do<br />
            do! loadThis<br />
            do! forNextIndex { return loadArgToStack }<br />
            do! field |&gt; setFieldFromStack  </p>
<p>        do! emitReturn<br />
    }<br />
[/fsharp]</p>
<p>And both builders:</p>
<p>[fsharp]<br />
(* encapsulates an incrementable index *)<br />
type IncrementingCounterBuilder () =<br />
    let mutable start = 0<br />
    member this.Return(expr) =<br />
        start &lt;- start + 1<br />
        expr start </p>
<p>(* Handles automatically passing the il generator through the requested calls *)<br />
type ILGenBuilder (gen: ILGenerator) =<br />
    member this.Bind(expr, func)=<br />
        expr gen<br />
        func () |&gt; ignore</p>
<p>    member this.Return(v) = ()<br />
    member this.Zero () = ()<br />
    member this.For(col, func) = for item in col do func item<br />
    member this.Combine expr1 expr2 = ()<br />
    member this.Delay expr = expr()<br />
[/fsharp]</p>
<p>Now all mutability and state is contained in the expression. I think this is a much cleaner implementation and the functions I used in the builder workflow didn't have to have their function signatures changed!</p>
<h2>Conclusion</h2>
<p>Sometimes you just jump in and don't realize the end goal won't work, but I did learn a whole lot figuring this out so the time wasn't wasted.</p>
<p>Check out full source at <a href="https://github.com/devshorts/Playground/tree/master/PowerShellCmdlets/Csv" target="_blank" rel="noopener noreferrer">my github</a>.</p>
