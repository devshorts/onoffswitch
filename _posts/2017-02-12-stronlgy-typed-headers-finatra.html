---
layout: post
title: Strongly typed http headers in finatra
date: 2017-02-12 00:31:26.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- finatra
- scala
meta:
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1558278890;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:4945;}i:1;a:1:{s:2:"id";i:4919;}i:2;a:1:{s:2:"id";i:4939;}}}}
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  _su_rich_snippet_type: none
  _wpcom_is_markdown: '1'
  _wpas_done_all: '1'
  _jetpack_dont_email_post_to_subs: '1'
  _wp_old_slug: passing-request-context-finatra
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2017/02/12/stronlgy-typed-headers-finatra/"
---
<p>When building service architectures one thing you need to solve is how to pass context between services. This is usually stuff like request id's and other tracing information (maybe you use <a href="http://zipkin.io/">zipkin</a>) between service calls. This means that if you set request id FooBar123 on an entrypoint to service A, if service A calls service B it should know that the request id is still FooBar123.  The bigger challenge is usually making sure that all thread locals keep this around (and across futures/execution contexts), but before you attempt that you need to get it into the system in the first place.</p>
<p>I'm working in <a href="https://twitter.github.io/finatra/">finatra</a> these days, and I love this framework. It's got all the things I loved from <a href="https://github.com/dropwizard/dropwizard">dropwizard</a> but in a scala first way. Todays challenge was that I wanted to be able to pass request http headers around between services in a typesafe way that could be used in thread local request contexts.  Basically I want to send</p>
<p>[code]<br />
X-Magic-Header someValue<br />
[/code]</p>
<p>And be able to resolve that into a <code>MagicHeader(value: T)</code> class.</p>
<p>The first attempt is easy, just parse header values into case classes:</p>
<p>[scala]<br />
case class MagicHeader(value: String)<br />
[/scala]</p>
<p>But the question I have is how do I enforce that the header string <code>X-Magic-Value</code> is directly correlated to the case class <code>MagicHeader</code>?</p>
<p>[scala]<br />
object MagicHeader {<br />
   val key = &quot;X-Magic-Header&quot;<br />
}</p>
<p>case class MagicHeader(value: String)<br />
[/scala]</p>
<p>Maybe, but still, when someone sends the value out, they can make a mistake:</p>
<p>[scala]<br />
setRequestHeader(&quot;X-mag1c-whatevzer&quot; -&gt; magicHeader.value)<br />
[/scala]</p>
<p>That sucks, I don't want that. I want it strictly paired. I'm looking for what is in essence a case class that has 2 fields: key, value, but where the key is <em>fixed</em>. How do I do that?</p>
<p>I like to start with how I want to use something, and then work backwards to how to make that happen. Given that, lets say we want an api kind of like:</p>
<p>[scala]<br />
object Experimental {<br />
  val key = &quot;Experimental&quot;</p>
<p>  override type Value = String<br />
}<br />
[/scala]</p>
<p>And I'd like to be able to do something like</p>
<p>[scala]<br />
val experimentKey = Experimental(&quot;experiment abc&quot;)<br />
(experimentKey.key -&gt; experimentKey.value) shouldEqual<br />
         (&quot;Experimental&quot; -&gt; &quot;experiment abc&quot;)<br />
[/scala]</p>
<p>I know this means I need an apply method somewhere, and I know that I want a tuple of (key, value). I also know that because I have a path dependent type of the second value, that I can do something with that</p>
<p>Maybe I can fake an apply  method to be like</p>
<p>[scala]<br />
trait ContextKey {<br />
  val key: String</p>
<p>  /**<br />
   * The custom type of this key<br />
   */<br />
  type Value</p>
<p>  /**<br />
   * A tupel of (String, Value)<br />
   */<br />
  type Key = Product2[String, Value]</p>
<p>  def apply(data: Value): Key = new Key {<br />
    override def _1: String = key</p>
<p>    override def _2: Value = data<br />
  }<br />
}<br />
[/scala]</p>
<p>And update my object to be</p>
<p>[scala]<br />
object Experimental extends ContextKey {<br />
  val key = &quot;Experimental&quot;</p>
<p>  override type Value = String<br />
}<br />
[/scala]</p>
<p>Now my object has a mixin of an apply method that creates an anonmyous tuple of type <code>String, Value</code>.  You can create instances of <code>Experimental</code> but you can't ever set the key name itself! However, I can still <em>access</em> the pinned key because the anonymous tuple has it!</p>
<p>But in the case that I wanted, I wanted to use these as http header values. Which means I need to be able to parse a string into a type of <code>ContextKey#Value</code> which is path dependent on the object type.</p>
<p>We can do that by adding now a few extra methods on the ContextKey trait:</p>
<p>[scala]<br />
trait ContextKeyType[T] extends Product2[String, T] {<br />
  def unparse: String<br />
}</p>
<p>trait ContextKey {<br />
  self =&gt;<br />
  val key: String</p>
<p>  /**<br />
   * The custom type of this key<br />
   */<br />
  type Value</p>
<p>  /**<br />
   * A tupel of (String, Value)<br />
   */<br />
  type Key = ContextKeyType[Value]</p>
<p>  /**<br />
   * Utility to allow the container to provide a mapping from Value =&gt; String<br />
   *<br />
   * @param r<br />
   * @return<br />
   */<br />
  def parse(r: String): Value</p>
<p>  def unparse(v: Value): String</p>
<p>  def apply(data: Value): Key = new Key {<br />
    override def _1: String = key</p>
<p>    override def _2: Value = data</p>
<p>    /**<br />
     * Allow a mapping of Value =&gt; String<br />
     *<br />
     * @return<br />
     */<br />
    override def unparse: String = self.unparse(data)</p>
<p>    override def equals(obj: scala.Any): Boolean = {<br />
      canEqual(obj)<br />
    }</p>
<p>    override def canEqual(that: Any): Boolean = {<br />
      that != null &amp;&amp;<br />
      that.isInstanceOf[ContextKeyType[_]] &amp;&amp;<br />
      that.asInstanceOf[ContextKeyType[_]]._1 == key &amp;&amp;<br />
      that.asInstanceOf[ContextKeyType[_]]._2 == data<br />
    }<br />
  }<br />
}<br />
[/scala]</p>
<p>This introduces a parse and unparse method which converts things to and from strings.  A http header object can now define how to convert it:</p>
<p>[scala]<br />
object Experimental extends ContextKey {<br />
  val key = &quot;Experimental&quot;<br />
  override type Value = String</p>
<p>  override def parse(value: String): String = value</p>
<p>  override def unparse(value: String): String = value<br />
}<br />
[/scala]</p>
<p>So, if we want to maybe send JSON in a header, or a long/int/uuid we can now parse and unparse that value pre and post wire.</p>
<p>Now lets add a utility to convert a <code>Map[String, String]</code> which could represent an http header map, into a set of strongly typed context values:</p>
<p>[scala]<br />
object ContextValue {<br />
  def find[T &lt;: ContextKey](search: T, map: Map[String, String]): Option[T#Value] = {<br />
    map.collectFirst {<br />
      case (key, value) if search.key == key =&gt; search.parse(value)<br />
    }<br />
  }<br />
}<br />
[/scala]</p>
<p>Back in finatra land, lets add a http filter</p>
<p>[scala]<br />
case class CurrentRequestContext(<br />
  experimentId: Option[Experimental.Value],<br />
)</p>
<p>object RequestContext {<br />
  private val requestType = Request.Schema.newField[CurrentRequestContext]</p>
<p>  implicit class RequestContextSyntax(request: Request) {<br />
    def context: CurrentRequestContext = request.ctx(requestType)<br />
  }</p>
<p>  private[filters] def set(request: Request): Unit = {<br />
    val data = CurrentRequestContext(<br />
      experimentId = ContextValue.find(Experimental, request.headerMap)<br />
    )</p>
<p>    request.ctx.update(requestType, data)<br />
  }<br />
}</p>
<p>/**<br />
 * Set the remote context from requests<br />
 */<br />
class RemoteContextFilter extends SimpleFilter[Request, Response] {<br />
  override def apply(request: Request, service: Service[Request, Response]): Future[Response] = {<br />
    RequestContext.set(request)</p>
<p>    service(request)<br />
  }<br />
}<br />
[/scala]</p>
<p>From here on out, we can provide a set of strongly typed values that are basically case classes with hidden keys</p>
