---
layout: post
title: Seq.unfold and creating bit masks
date: 2013-09-09 20:28:22.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- bits
- byte
- F#
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  _su_rich_snippet_type: none
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1559923232;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:4213;}i:1;a:1:{s:2:"id";i:3615;}i:2;a:1:{s:2:"id";i:4286;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2013/09/09/seq-unfold-creating-bit-masks/"
---
<p>In the course of working on  <a href="https://github.com/devshorts/ParsecClone" target="_blank" rel="noopener noreferrer">ParsecClone</a> I needed some code that could take in an arbitrary byte array and convert it to a corresponding bit array. The idea is if I have an array of </p>
<p>[fsharp]<br />
[|byte 0xFF;byte 0x01|]<br />
[/fsharp]</p>
<p>Then I should get</p>
<p>[fsharp]<br />
[|1;1;1;1;1;1;1;0;0;0;0;0;0;0;1|]<br />
[/fsharp]</p>
<p>I've done plenty of bit slingin' in my day, and the trick is just to apply a sequence of bit masks to each byte and collect all the bit arrays.  In other languages this is always a little bit of a pain, but in F# the solution was amazingly elegant</p>
<h2>Data</h2>
<p>As with anything F#, I like to start with the data</p>
<p>[fsharp]<br />
type Bit =<br />
    | One<br />
    | Zero<br />
    override this.ToString() =<br />
        match this with<br />
            | One -&gt; &quot;1&quot;<br />
            | Zero -&gt; &quot;0&quot;<br />
[/fsharp]</p>
<h2>Make bit masks</h2>
<p>Now lets generate the meat and potatoes of this: a sequence of bit masks</p>
<p>[fsharp]<br />
let bitMasks = Seq.unfold (fun bitIndex -&gt; Some((byte(pown 2 bitIndex), bitIndex), bitIndex + 1)) 0<br />
                        |&gt; Seq.take 8<br />
                        |&gt; Seq.toList<br />
                        |&gt; List.rev<br />
[/fsharp]</p>
<p>While a <code>fold</code> takes a list and a seed and returns a single accumulated item, an <code>unfold</code> takes a seed and generates a list.  For those not familiar, <code>unfold</code> takes a function of the signature</p>
<p>[fsharp]<br />
(State -&gt; ('a * State) option) -&gt; State -&gt; Seq&lt;'a&gt;<br />
[/fsharp]</p>
<p>Unfold takes a function with an argument that is the state, and returns an <code>item * state</code> option tuple.  The first element of the option is the element to be emitted in the sequence. The second item is the <em>next</em> state.  If you return <code>None</code> instead of <code>Some</code> the infinite sequence will end. You can see that my state is the exponent n of <em>2^n</em> which gives you the bit mask. The first iteration is 2^0, then 2^1, then 2^2, etc.  By reversing it, I now have a bitmask that look like this:</p>
<p>[fsharp]<br />
[2^7; 2^6; 2^5; 2^4; 2^3; 2^2; 2^1; 2^0]<br />
[/fsharp]</p>
<h2>Byte to Bits</h2>
<p>The next thing is to apply the bitmask to a byte.</p>
<p>[fsharp]<br />
let byteToBitArray b =<br />
        List.map (fun (bitMask, bitPosition) -&gt;<br />
                    if (b &amp;&amp;&amp; bitMask) &gt;&gt;&gt; bitPosition = byte(0) then Zero<br />
                    else One) bitMasks<br />
[/fsharp]</p>
<p>The unusual thing here is that bitwise and is the <code>&&&</code> operator and bitwise shift is the >>> operator.  Not that weird, but different from other langauges. </p>
<h2>Bytes to Bits</h2>
<p>All that's left is applying the byteToBitArray function to byte array to get a bit array</p>
<p>[fsharp]<br />
let bytesToBits (bytes:byte[]) =<br />
    bytes<br />
        |&gt; Array.toList<br />
        |&gt; List.map byteToBitArray<br />
        |&gt; List.collect id<br />
        |&gt; List.toArray<br />
[/fsharp]</p>
<p>And now to test it in fsi</p>
<p>[fsharp]<br />
&gt; bytesToBits [|byte 0xFF;byte 0x01|];;<br />
val it : Bit [] =<br />
  [|One; One; One; One; One; One; One; One; Zero; Zero; Zero; Zero; Zero; Zero;<br />
    Zero; One|]<br />
[/fsharp]</p>
<h2>Bits To UInt</h2>
<p>We can even take a bit array and create a uint now too</p>
<p>[fsharp]<br />
let bitsToUInt (bits:Bit[])  =<br />
   let positions = Array.zip bits (Array.rev [|0..Array.length bits - 1|])</p>
<p>   Array.fold (fun acc (bit, index) -&gt;<br />
                   match bit with<br />
                       | Zero -&gt; acc<br />
                       | One -&gt; acc + (pown 2 index)) 0 positions<br />
[/fsharp]</p>
<p>First I zip the bit array with each position in the bit array. Then we just need to fold over the array and add the accumulator to <em>2^n</em> if the bit is a one.  </p>
<p>[fsharp]<br />
&gt; [|One; One; One; One; One; One; One; Zero;|] |&gt; bitsToUInt;;<br />
val it : int = 254<br />
[/fsharp]</p>
<h2>Conclusion</h2>
<p>I really enjoyed working with the higher order functions that F# provides to make a simple and robust conversion.  Working with strongly typed data felt more robust than dealing with just integers.  </p>
