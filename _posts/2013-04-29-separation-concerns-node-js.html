---
layout: post
title: Separation of concerns in node.js
date: 2013-04-29 08:00:23.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Snippets
tags:
- node.js
- typescript
meta:
  _syntaxhighlighter_encoded: '1'
  _su_rich_snippet_type: none
  _edit_last: '1'
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1560893531;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:4515;}i:1;a:1:{s:2:"id";i:4028;}i:2;a:1:{s:2:"id";i:2635;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2013/04/29/separation-concerns-node-js/"
---
<p>I've been playing with typescript and node.js and I wanted to talk a little about how I've broken up my app source.  It's always good to modularize an application into smaller bits, and while node lets you do a lot, quickly, with just a little bit of code, as your application grows you really can't put all your logic in one big <code>app.ts</code>.</p>
<h2>App.ts</h2>
<p>Instead of the normal application example you see for node projects, I wanted to make it clearer what the initialization of my application does.  My app start is structured like this:</p>
<p>[ts]<br />
/**<br />
 * Module dependencies.<br />
 */</p>
<p>import db = module(&quot;./storage/storageContainer&quot;);<br />
import auth = module(&quot;./auth/oauthDefinitions&quot;);<br />
import requestBase = module(&quot;./routes/requestBase&quot;);</p>
<p>var express = require('express')<br />
    , routes = require('./routes')<br />
    , http = require('http')<br />
    , path = require('path')<br />
    , log = require(&quot;./utils/log.js&quot;)<br />
    , fs = require('fs')<br />
    , passport = require('passport');</p>
<p>var app = express();</p>
<p>class AppEntry{<br />
    constructor(){<br />
        this.initDb();<br />
        this.setupRoutes();<br />
        this.defineOAuth();<br />
        this.startServer();<br />
    }</p>
<p>    // initialization functions<br />
}</p>
<p>var application = new AppEntry();<br />
[/ts]</p>
<p>The upside to this kind of simple structure is that it's easy to see what the entrypoint structure is.  Adding new initialization logic is encapsulated and isn't intermingled among route configurations, OAuth authorization code, server start, database initialization, etc.  Having a monolithic app can quickly get into a tangled mess. </p>
<p>You may have noticed that I didn't pass in any required modules or references to the application. This is because I'm relying on the class initialization closure to capture the variables to keep function signatures clean.  I opted to use a class instead of a module for no particular reason other than I like classes and forgot modules existed when I did this.</p>
<h2>Storage</h2>
<p>Even though I'm using mongoose as my mongoDB ORM, I still have tried to move all the storage logic in special storage classes.  This means that any outside access to storage has to go through classes that wrap the storage calls.  I've mentioned it before, but I think it's always good practice to not entangle an application with specific 3rd party libraries (if you can avoid it).  Also having storage classes means I can hide away internal mongo calls, if necessary, and let me do extra data manipulation outside of the context that wants the data.  </p>
<p>To make accessing the storage classes easy for myself, I have split them up into separate classes based on what they most commonly access. For example, there is a <code>userStorage</code> class, and a <code>trackStorage</code> class, etc.  Each class contains relevant CRUD and helper methods to aggregate the data in forms that I commonly use them.</p>
<p>Unfortunately, the way node works is that in each module you work in, if you wanted access to a storage class you'd have to import each one independently (one import for users, one import for dataPoints, etc).  That's a pain. Instead, I've wrapped the storage classes with a single exported singleton container. </p>
<p>[ts]<br />
// storageContainer.ts</p>
<p>import schemaImport = module(&quot;./schema&quot;);<br />
import users = module(&quot;./userStorage&quot;);<br />
import tracks = module(&quot;./trackStorage&quot;)</p>
<p>export var storage:schemaImport.db = new schemaImport.db();<br />
export var userStorage:users.userStorage = new users.userStorage();<br />
export var schema = schemaImport;<br />
export var trackStorage:tracks.trackStorage = new tracks.trackStorage();<br />
[/ts]</p>
<p>Anywhere I want access to storage classes, I only need to import one module:</p>
<p>[ts]<br />
import db = module(&quot;./storage/storageContainer&quot;);</p>
<p>// ...</p>
<p>db.userStorage.getUserByUsername(...)<br />
[/ts]</p>
<p>Adding new storage classes and updating the singleton container means I have access to these everywhere I need them without having to worry about importing and instantiating modules.</p>
<h2>Definition files</h2>
<p>Like the storage classes, the same pattern goes for definition files.  I've made a folder called <code>def</code> and created an <code>all.d.ts</code> that just has reference path's to all my other definition mappings.  </p>
<p>[ts]<br />
///&lt;reference path=&quot;./mongoose.d.ts&quot;/&gt;<br />
///&lt;reference path=&quot;./nodeUnit.d.ts&quot;/&gt;<br />
///&lt;reference path=&quot;./schemaDef.d.ts&quot;/&gt;<br />
///&lt;reference path=&quot;./passport.d.ts&quot;/&gt;<br />
[/ts]</p>
<p>Any other file that needs definition mappings can include the one all aggregate. Since it costs nothing and is just a compiler hint, there's no resource hit.</p>
<h2>Routes</h2>
<p>And again, I do the same kind of pattern with routes. I have a folder setup like this:</p>
<p>[code]<br />
routes<br />
├── index.js<br />
├── indexRoutes.ts<br />
├── userRoutes.ts<br />
├── ... etc<br />
[/code]</p>
<p>Where index.js looks like this:</p>
<p>[javascript]<br />
var userRoutes = require(&quot;./userRoutes&quot;);<br />
var indexRoutes = require(&quot;./indexRoutes&quot;);<br />
var trackRoutes = require(&quot;./trackRoutes&quot;);<br />
var partialsRoutes = require(&quot;./partialsRoutes&quot;);</p>
<p>module.exports = function(app){<br />
    new userRoutes.userRoutes(app);<br />
    new indexRoutes.indexRoutes(app);<br />
    new trackRoutes.trackRoutes(app);<br />
    new partialsRoutes.partialsRoutes(app);<br />
};<br />
[/javascript]</p>
<p>From my main application, I import the routes module and pass it the app reference. I know that <a href="http://dailyjs.com/2012/01/26/effective-node-modules/" target="_blank" rel="noopener noreferrer">app is global in a node application</a>, however, I don't like relying on globals. It was just as easy to pass app as an argument and I prefer that flow control.  </p>
<p>[ts]<br />
routes = require('./routes')<br />
routes(app);<br />
[/ts]</p>
<p>In each of the route modules, I then go back to typescript</p>
<p>[ts]<br />
import db = module(&quot;../storage/storageContainer&quot;);</p>
<p>import base = module(&quot;./requestBase&quot;);</p>
<p>export class userRoutes {<br />
    constructor(app:ExpressApplication) {<br />
        var requestUtils = new base.requestBase();</p>
<p>        app.get('/logout', (req:any, res) =&gt; {<br />
            req.logout();<br />
            res.redirect('/');<br />
        });</p>
<p>        app.get(&quot;/users&quot;, requestUtils.ensureAuthenticated, (req, res) =&gt; {<br />
            res.send(req.user.name);<br />
        });<br />
}<br />
[/ts]</p>
<p>So at this point I'm using the definition files from <a href="https://github.com/borisyankov/DefinitelyTyped" target="_blank" rel="noopener noreferrer">DefinitelyTyped</a> for my express application. Also you can see that I'm injecting custom middleware into my routes for things that I want to make sure are authenticated.  The point being that the routes class is now self encapsulated, and we don't need to modify the main entry point to the application anymore.  We update the routes index page and create a route object and that's it.</p>
<h2>Conclusion</h2>
<p>It's been fun playing in node, and while I see myself doing some things the .NET way, I'm also trying to embrace the node way. However, when it comes to module organization the node projects I've seen have been seriously lacking.  While it does mean more boilerplate upfront, I think making sure to split up your files helps maintain a separation of concerns and your project extensible.</p>
