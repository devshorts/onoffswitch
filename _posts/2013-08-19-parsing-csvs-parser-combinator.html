---
layout: post
title: Parse whatever with your own parser combinator
date: 2013-08-19 08:00:32.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- ast
- combinators
- F#
- fparsec
- parsing
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  _su_rich_snippet_type: none
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1558681316;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:4068;}i:1;a:1:{s:2:"id";i:3723;}i:2;a:1:{s:2:"id";i:4213;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2013/08/19/parsing-csvs-parser-combinator/"
---
<p>In a few recent posts I talked about playing with fparsec to parse data into usable syntax trees.  But, even after all the time spent fiddling with it, I really didn't fully understand how combinators actually worked. With that in mind, I decided to build a version of fparsec from scratch. What better way to understand something than to build it yourself?  I had one personal stipulation, and that was to not look at the fparsec source.  To be fair, I cheated with one function (the very first one) so I kind of cheated a lot, but I didn't peek at anything else, promise.</p>
<h2>Combinators</h2>
<p>The principle behind combinators is that they are a way to take two functions and combine them into another function.  Functional programming is chock full of this pattern. In general, you can combine any function to get any other function, but what makes a combinator powerful is when you combine a function, with another function, and get the same signature as the first function.  Now you can recursively combine functions together.  </p>
<p>For example, lets say I have a function defined like this:</p>
<p>[fsharp]<br />
let parser = state -&gt; result * state<br />
[/fsharp]</p>
<p>So it takes some input state, and gives you some sort of result along with a new state.</p>
<p>To make this useful though, I need to get the result and do something else with it.  So, lets say I have another function that takes a result, and gives you a function that takes a new state and returns a new result. </p>
<p>[fsharp]<br />
let applier = result -&gt; (state -&gt; result * state)<br />
[/fsharp]</p>
<p>Is it possible to combine these two somehow? Sure:</p>
<p>[fsharp]<br />
let combiner parser applier =<br />
   fun state -&gt;<br />
     match parser state with<br />
      | (Some(result), newState) -&gt;<br />
             let nextParser = applier result<br />
             nextParser newState<br />
      | (None, newState) -&gt; (None, newState)<br />
[/fsharp]</p>
<p>What's the function signature of this combiner function?</p>
<p>[fsharp]<br />
(state -&gt; result * state) -&gt; (result -&gt; (state -&gt; result * state)) -&gt; (state -&gt; result * state)<br />
[/fsharp]</p>
<p>That's kind of a mouthful, so lets add a type alias:</p>
<p>[fsharp]<br />
type Parser = state -&gt; result * state<br />
[/fsharp]</p>
<p>Now what is the type signature?</p>
<p>[fsharp]<br />
Parser -&gt; (result -&gt; Parser) -&gt; Parser<br />
[/fsharp]</p>
<p>That's a lot better.</p>
<p>We've just defined a way to take some function that takes a state and returns a result, combine it with something that takes a result and returns a new function, and it gives you a NEW parser.  So you've combined the two things together to create the same kind of thing as the first thing!</p>
<p>What's neat about this is you can use this basic <code>combiner</code> function to build up parsers that do small work.</p>
<h2>Define a simple parser</h2>
<p>Building a parser function is easy, it can be anything. Remembering the signature:</p>
<p>[fsharp]<br />
state -&gt; result * state<br />
[/fsharp]</p>
<p>Here is something that parsers a single character from a string:</p>
<p>[fsharp]<br />
let oneCharParser =<br />
       fun (state:string) -&gt;<br />
          let firstChar = state.Chars(0)<br />
          let remainingState = state.Substring(0, state.Length - 1)<br />
          (Some(firstChar), remainingState)<br />
[/fsharp]</p>
<p>You can create more complex parsers too, maybe one that takes a regular expression or matches on a specific string.  Anything you want.</p>
<h2>Building on the combiner</h2>
<p>Now that there is a combiner, and a way to define a parser, lets build on that. First lets alias the <code>combiner</code> function I first wrote out to make it a little easier to use:</p>
<p>[fsharp]<br />
let (&gt;&gt;=) current next = combiner current next<br />
[/fsharp]</p>
<p>This operator, mimics the syntax from fparsec (and haskells parsec).  Next, lets make a combinator function that takes two parsers, and returns the result of the second parser (ignoring the result of the first):</p>
<p>[fsharp]<br />
let (&gt;&gt;.)  parser1 parser2  =<br />
    parser1 &gt;&gt;= fun firstResult -&gt;<br />
    parser2 &gt;&gt;= fun secondResult -&gt;<br />
         secondResult<br />
[/fsharp]</p>
<p>But wait, that won't really work.  Remember that the combiners second argument wants a function that takes a result and returns a parser (which is a function that takes a state and returns a result) [i.e. of the signature <code>result -> (state -> result * state)</code>.</p>
<p>If you look closely, we aren't returning a parser at the end of this, we are just returning a value (i.e. just <code>result</code>).  We need some sort of way to return a value as a parser.  Hmm, fparsec has this and its called <code>preturn</code>. Let's add this too:</p>
<p>[fsharp]<br />
let preturn value = fun state -&gt; (Some(value), state)<br />
[/fsharp]</p>
<p>Not so bad. Now lets tie it in:</p>
<p>[fsharp]<br />
let (&gt;&gt;.)  parser1 parser2  =<br />
        parser1 &gt;&gt;= fun firstResult -&gt;<br />
        parser2 &gt;&gt;= fun secondResult -&gt;<br />
        preturn secondResult<br />
[/fsharp]</p>
<p>Awesome, now the magic that is the F# type inference system is happy!</p>
<p>But, we can do so much more.  If all we need to do is create custom operators that leverage the combiner function we can create functions that:</p>
<ul>
<li>Takes two parsers and returns the first (<code>.>></code>)</li>
<li>Takes two parsers and returns the second (<code>>>.</code>)</li>
<li>Takes two parsers and returns a tuple of the result (<code>.>>.</code>)</li>
<li>Takes a parser and preturns its value into a parameterized discriminated union type (<code>|>></code>)</li>
<li>Takes a parser and preturns its value into a non parameterized discriminated union type (<code>|>>%</code>)</li>
</ul>
<h2>State</h2>
<p>In FParsec and other combinators, the state is a character stream. But when building out my own parsec clone I saw no reason that the state had to be tied to a specific type.  Parser states share a few things in common:</p>
<ul>
<li>Consume and return a consumed value</li>
<li>Backtrack to a position</li>
<li>Test if the state contains a predicate</li>
<li>Know if they are empty</li>
</ul>
<p>When building my parser I kept this in mind and made the combinator library work on a general state interface that I called <code>IStreamP</code></p>
<p>[fsharp]<br />
type IStreamP&lt;'StateType, 'ConsumeType&gt; =<br />
    abstract member state : 'StateType<br />
    abstract member consume : int -&gt; 'ConsumeType option * IStreamP&lt;'StateType, 'ConsumeType&gt;<br />
    abstract member backtrack : unit -&gt; unit<br />
    abstract member hasMore : unit -&gt; bool<br />
[/fsharp]</p>
<p>Using this interface I was able to implement a string parser state, as well as a binary parser state.  Both states can be reused with all the combinator functions which is part of what makes parser combinators so robust.  You get to mix language functionality with the grammar you are parsing.</p>
<h2>An example</h2>
<p>Now that I have all the basic building blocks, lets try parsing a CSV. The bulk of the work is being able to parse a string.  But to parse a string, we have to see if the state matches something.  So lets start with that. The combinator I wrote has a generic match function that you inject a predicate to:</p>
<p>[fsharp]<br />
let matcher eval target =<br />
    fun currentState -&gt;<br />
        match eval currentState target with<br />
            | Some(amount) -&gt; currentState.consume amount<br />
            | None         -&gt; (None, currentState)<br />
[/fsharp]</p>
<p>The signature of the eval function is:</p>
<p>[fsharp]<br />
state -&gt; 'a -&gt; int<br />
[/fsharp]</p>
<p>So an evaluator function takes the current state, and some sort of target (maybe you are trying to match on a specific string) and if the predicate returns some integer amount, the state consumes the amount the predicate told it to take.  A simple way of doing this is to see if the beginning of the string matches what you want to take:</p>
<p>[fsharp]<br />
type ParseState = State&lt;string, string&gt;</p>
<p>let private getStringStream (state:ParseState) = (state :?&gt; StringStreamP)</p>
<p>let private startsWith (input:ParseState) target = (input |&gt; getStringStream).startsWith input target</p>
<p>let matchStr str = matcher startsWith str<br />
[/fsharp]</p>
<p>Basically its just getting a starts with expression match function from the state class. The idea here is that each state class can contain its own predicates to match on, so you don't have to mix stuff between a binary state parser and a string state parser.  </p>
<p>And just to show what the startsWith function looks like:</p>
<p>[fsharp]<br />
member x.startsWith (inputStream:IStreamP&lt;string, string&gt;) target =<br />
      if String.IsNullOrEmpty inputStream.state then None<br />
      else if inputStream.state.StartsWith target then<br />
          Some target.Length<br />
      else None</p>
<p>[/fsharp]</p>
<p>Building on this we can create matches that match using regex, or do other work.  Taking kind of a leap of faith here, let me show the finished CSV parser (full source is on my <a href="https://github.com/devshorts/ParsecClone" target="_blank" rel="noopener noreferrer">github</a>)</p>
<p>[fsharp]<br />
let delimType = &quot;,&quot;</p>
<p>let(|DelimMatch|EscapedType|Other|) i =<br />
    if i = &quot;\\&quot; || i =&quot;\&quot;&quot; then EscapedType<br />
    else if i = delimType then DelimMatch<br />
    else Other</p>
<p>let delim&lt;'a&gt; = matchStr delimType</p>
<p>let quote  = matchStr &quot;\&quot;&quot;</p>
<p>let validNormalChars = function<br />
                        | EscapedType<br />
                        | DelimMatch -&gt; false<br />
                        | rest -&gt; not (isNewLine rest)</p>
<p>let inQuotesChars  = function<br />
                        | &quot;\&quot;&quot; -&gt; false<br />
                        | _ -&gt; true</p>
<p>let unescape = function<br />
                    | &quot;n&quot; -&gt; &quot;\n&quot;<br />
                    | &quot;r&quot; -&gt; &quot;\r&quot;<br />
                    | &quot;t&quot; -&gt; &quot;\t&quot;<br />
                    | c   -&gt; c</p>
<p>let quoteStrings = (many (satisfy (inQuotesChars) any)) &gt;&gt;= foldChars</p>
<p>let escapedChar&lt;'a&gt; = matchStr &quot;\\&quot; &gt;&gt;. (anyOf matchStr [delimType; &quot;\&quot;&quot;;&quot;n&quot;;&quot;r&quot;;&quot;t&quot;] |&gt;&gt; unescape)</p>
<p>let normal&lt;'a&gt; = satisfy validNormalChars any </p>
<p>let normalAndEscaped = many (normal &lt;|&gt; escapedChar) &gt;&gt;= foldChars</p>
<p>let literal&lt;'a&gt; = between quote quoteStrings quote</p>
<p>let csvElement = ws &gt;&gt;. (literal &lt;|&gt; normalAndEscaped)</p>
<p>let listItem&lt;'a&gt; = delim &gt;&gt;. opt csvElement</p>
<p>let elements&lt;'a&gt; = csvElement .&lt;?&gt;&gt;. many listItem</p>
<p>let lines&lt;'a&gt; = many (elements |&gt; sepBy &lt;| newline) .&gt;&gt; eof<br />
[/fsharp]</p>
<p>It should look very similiar to fparsec, but slightly different. For example, the [code].&lt;?&gt;&gt;.[/code] operator takes an item parser, and an item list parser, and optionally applies both the item and the list. If the list returns any results it preturns the first item with the item list, otherwise just returns the first item.  </p>
<h2>Another example</h2>
<p>Just to demonstrate the power of decoupling the combinator logic from the state/stream logic, lets use the same combinator functions on a binary stream:</p>
<p>If we implement a new binary state stream, it might look like this:</p>
<p>[fsharp]<br />
type BinStream (state:Stream) =<br />
    let startPos = state.Position</p>
<p>    interface IStreamP&lt;Stream, byte[]&gt;  with<br />
        member x.state = state     </p>
<p>        member x.consume (count) =<br />
            let mutable bytes = Array.init count (fun i -&gt; byte(0))<br />
            state.Read(bytes, 0, count) |&gt; ignore</p>
<p>            (Some(bytes), new BinStream(state) :&gt; IStreamP&lt;Stream, byte[]&gt; )</p>
<p>        member x.backtrack () = state.Seek(startPos, SeekOrigin.Begin) |&gt; ignore</p>
<p>        member x.hasMore () = state.Position &lt;&gt; state.Length</p>
<p>    member x.streamCanBeConsumed (state:IStreamP&lt;Stream, byte[]&gt; ) count =<br />
        if (int)state.state.Position + (int)count &lt;= (int)state.state.Length then<br />
            Some(count)<br />
        else<br />
            None<br />
[/fsharp]</p>
<p>And we can define a whole bunch of basic parsers to work with this stream:</p>
<p>[fsharp]<br />
module BinParser = </p>
<p>    let private byteToInt (b:byte) = System.Convert.ToInt32(b)<br />
    let private toInt16 v = System.BitConverter.ToInt16(v, 0)<br />
    let private toInt32 v = System.BitConverter.ToInt32(v, 0)<br />
    let private toInt64 v = System.BitConverter.ToInt64(v, 0)</p>
<p>    type ParseState = State&lt;Stream, byte[]&gt;</p>
<p>    let private getBinStream (state:ParseState) = (state :?&gt; BinStream)</p>
<p>    let private streamCanBeConsumed (state:ParseState) count  = (state |&gt; getBinStream).streamCanBeConsumed state count</p>
<p>    let private binMatch (num:int) = matcher streamCanBeConsumed num        </p>
<p>    let byteN&lt;'a&gt; = binMatch </p>
<p>    let byte1&lt;'a&gt; = byteN 1 &gt;&gt;= fun b1 -&gt; preturn b1.[0]  </p>
<p>    let byte2&lt;'a&gt; = byteN 2  </p>
<p>    let byte3&lt;'a&gt; = byteN 3</p>
<p>    let byte4&lt;'a&gt; = byteN 4</p>
<p>    let int16&lt;'a&gt; = byte2 |&gt;&gt; toInt16</p>
<p>    let int32&lt;'a&gt; = byte4 |&gt;&gt; toInt32</p>
<p>    let int64&lt;'a&gt; = byteN 8 |&gt;&gt; toInt64</p>
<p>    let intB&lt;'a&gt; = byte1 |&gt;&gt; byteToInt<br />
[/fsharp]</p>
<p>And here is a unit test to show how it might be used:</p>
<p>[fsharp]<br />
[&lt;Test&gt;]<br />
let ``test reading two sets of 4 bytes``() =<br />
    let bytes = [|0;1;2;3;4;5;6;7;8|] |&gt; Array.map byte</p>
<p>    let stream = new MemoryStream(bytes)   </p>
<p>    let binaryStream = new BinStream(stream) </p>
<p>    let parser = manyN 2 byte4</p>
<p>    let result = test binaryStream parser </p>
<p>    result |&gt; should equal [[|0;1;2;3|];[|4;5;6;7|]]<br />
[/fsharp]</p>
<h2>Conclusion</h2>
<p>What I like about combinators is that you build on the smallest blocks.  And, unlike parser generators, you can mix language constructs with your grammar.  Unfortunately debugging combinators is extremely difficult, since each combinator is a function that is composed of other functions.  When you build a complex grammar up from those blocks, its easy to get lost in which function you are in and where you came from.  The up side is that you can easily test against each building block independently.  </p>
