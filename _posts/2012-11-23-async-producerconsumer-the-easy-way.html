---
layout: post
title: Async producer/consumer the easy way
date: 2012-11-23 10:56:35.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
- Imported
tags:
- c#
- design patterns
meta:
  _syntaxhighlighter_encoded: '1'
  _wp_old_slug: asynch-producerconsumer-the-easy-way
  _edit_last: '1'
  dsq_thread_id: '940776371'
  _su_title: ''
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1561850503;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:4435;}i:1;a:1:{s:2:"id";i:4394;}i:2;a:1:{s:2:"id";i:2447;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2012/11/23/async-producerconsumer-the-easy-way/"
---
<p><em>This article was originally published at <a href="http://tech.blinemedical.com/async-producerconsumer-the-easy-way/" target="_blank" rel="noopener noreferrer">tech.blinemedical.com</a></em></p>
<p>In .net 4, a new class called <a href="http://msdn.microsoft.com/en-us/library/dd267312.aspx"><code>BlockingCollection</code></a> was introduced, which let you have a <a href="http://en.wikipedia.org/wiki/Thread_safety">threadsafe</a> <a href="http://en.wikipedia.org/wiki/Producer-consumer_problem">producer/consumer</a> queue. Anyone consuming a <code>BlockingCollection</code> blocks automatically until new items are added. This lets you easily add items to the collection in one thread and use another synchronized thread to consume items. This class is great since before this existed, you had to do all this work with mutexes and it was a lot of extra work (and more error prone). In general, a good time to use a decoupled producer consumer pattern is when you have a slow consuming function and a producer thread that is time sensitive.</p>
<p>Even though <code>BlockingCollection</code> effectively synchronizes your producer/consumer, you still have to create <a href="http://en.wikipedia.org/wiki/Boilerplate_code">boilerplate</a> to manage the producer thread and the consumer thread. Also if you wanted to add extra exception handling or a <a href="http://msdn.microsoft.com/en-us/library/dd997364.aspx">cancellation token,</a> you'd have to add all that yourself too. I wrapped this all up in a <code><a href="https://github.com/blinemedical/BlockingCollectionWrapper/blob/master/BlockingCollectionWrapper/BlockingCollectionWrapper.cs" target="_blank" rel="noopener noreferrer">BlockingCollectionWrapper</a></code> class that handles all this for you.</p>
<h1>An example</h1>
<p>Here is an example where the consumer takes one second each time it consumes an item.</p>
<p>[csharp]<br />
private readonly ManualResetEvent _testMutex = new ManualResetEvent(false);</p>
<p>[Test]<br />
public void TestCollection()<br />
{<br />
    // create the wrapper<br />
    var asyncCollection = new BlockingCollectionWrapper&lt;string&gt;();</p>
<p>    asyncCollection.FinishedEvent += FinishedEventHandler;</p>
<p>    // make sure we dispose of it. this will stop the internal thread<br />
    using (asyncCollection)<br />
    {<br />
        // register a consuming action<br />
        asyncCollection.QueueConsumingAction = (producedItem) =&gt;<br />
        {<br />
            Thread.Sleep(TimeSpan.FromSeconds(1));<br />
            Console.WriteLine(DateTime.Now + &quot;: Consuming item: &quot; + producedItem);<br />
        };</p>
<p>        // start consuming<br />
        asyncCollection.Start();</p>
<p>        // start producing<br />
        for (int i = 0; i &lt; 10; i++)<br />
        {<br />
            Console.WriteLine(DateTime.Now + &quot;: Produced item &quot; + i);<br />
            asyncCollection.AddItem(i.ToString());<br />
        }<br />
    }</p>
<p>    // wait for the finished handler to pulse this<br />
    _testMutex.WaitOne();</p>
<p>    Assert.True(asyncCollection.Finished);<br />
}</p>
<p>private void FinishedEventHandler(object sender, BlockingCollectionEventArgs e)<br />
{<br />
    _testMutex.Set();<br />
}<br />
[/csharp]</p>
<p>This prints out</p>
<p>[csharp]<br />
9/17/2012 6:22:43 PM: Produced item 0<br />
9/17/2012 6:22:43 PM: Produced item 1<br />
9/17/2012 6:22:43 PM: Produced item 2<br />
9/17/2012 6:22:43 PM: Produced item 3<br />
9/17/2012 6:22:43 PM: Produced item 4<br />
9/17/2012 6:22:43 PM: Produced item 5<br />
9/17/2012 6:22:43 PM: Produced item 6<br />
9/17/2012 6:22:43 PM: Produced item 7<br />
9/17/2012 6:22:43 PM: Produced item 8<br />
9/17/2012 6:22:43 PM: Produced item 9<br />
9/17/2012 6:22:44 PM: Consuming item: 0<br />
9/17/2012 6:22:45 PM: Consuming item: 1<br />
9/17/2012 6:22:46 PM: Consuming item: 2<br />
9/17/2012 6:22:47 PM: Consuming item: 3<br />
9/17/2012 6:22:48 PM: Consuming item: 4<br />
9/17/2012 6:22:49 PM: Consuming item: 5<br />
9/17/2012 6:22:50 PM: Consuming item: 6<br />
9/17/2012 6:22:51 PM: Consuming item: 7<br />
9/17/2012 6:22:52 PM: Consuming item: 8<br />
9/17/2012 6:22:53 PM: Consuming item: 9<br />
[/csharp]</p>
<p>First, I created the blocking collection wrapper and made sure to put it in a <code>using</code> block since it's disposable (the thread waiting on the blocking collection will need to be cleaned up). Then I registered a function to be executed each time an item is consumed. Calling <code>Start()</code> begins consuming. Once I'm done - even after the using block disposes of the wrapper - the separate consumer thread could still be running (processing whatever is left), but it is no longer blocking on additions and will complete consuming any pending items.</p>
<h1>The wrapper</h1>
<p>When you call <code>.Start()</code> we start our independent consumer thread.</p>
<p>[csharp]<br />
/// &lt;summary&gt;<br />
/// Start the consumer<br />
/// &lt;/summary&gt;<br />
public void Start()<br />
{<br />
    _cancellationTokenSource = new CancellationTokenSource();<br />
    _thread = new Thread(QueueConsumer) {Name = &quot;BlockingConsumer&quot;};<br />
    _thread.Start();<br />
}<br />
[/csharp]</p>
<p>This is the queue consumer that runs in the separate thread that executes the registered consumer action. The consuming action is locked to make changing the consuming action threadsafe.</p>
<p>[csharp]<br />
/// &lt;summary&gt;<br />
/// The actual consumer queue that runs in a seperate thread<br />
/// &lt;/summary&gt;<br />
private void QueueConsumer()<br />
{<br />
    try<br />
    {<br />
        // Block on _queue.GetConsumerEnumerable<br />
        // When an item is added to the _queue it will unblock and let us consume<br />
        foreach (var item in _queue.GetConsumingEnumerable(_cancellationTokenSource.Token))<br />
        {<br />
            // get a synchronized snapshot of the action<br />
            Action&lt;T&gt; consumerAction = QueueConsumingAction;</p>
<p>            // execute our registered consuming action<br />
            if (consumerAction != null)<br />
            {<br />
                consumerAction(item);<br />
            }<br />
        }</p>
<p>        // dispose of the token source<br />
        if (_cancellationTokenSource != null)<br />
        {<br />
            _cancellationTokenSource.Dispose();<br />
        }</p>
<p>        //Log.Debug(this, &quot;Done with queue consumer&quot;);</p>
<p>        Finished = true;</p>
<p>        if (FinishedEvent != null)<br />
        {<br />
            FinishedEvent(this, new BlockingCollectionEventArgs());<br />
        }<br />
    }<br />
    catch(OperationCanceledException)<br />
    {<br />
        //Log.Debug(this, &quot;Blocking collection&lt;{0}&gt; cancelled&quot;, typeof(T));<br />
    }<br />
    catch (Exception ex)<br />
    {<br />
        //Log.Error(this, ex, &quot;Error consuming from queue of type {0}&quot;, typeof(T));<br />
    }<br />
}<br />
[/csharp]</p>
<p>And when the wrapper is disposed, we set <code><a href="http://msdn.microsoft.com/en-us/library/dd287086.aspx" target="_blank" rel="noopener noreferrer">CompleteAdding</a></code> on the blocking collection which tells the collection to stop waiting for new additions and finish out whatever is left in the queue.</p>
<p>[csharp]<br />
protected void Dispose(bool disposing)<br />
{<br />
    if(disposing)<br />
    {<br />
        if (_queue !=null &amp;&amp; !_queue.IsAddingCompleted)<br />
        {<br />
            // mark the queue as complete<br />
            // the BlockingConsumer thread will now<br />
            // just process the remaining items<br />
            _queue.CompleteAdding();<br />
        }<br />
    }<br />
}</p>
<p>public void Dispose()<br />
{<br />
    Dispose(true);<br />
}<br />
[/csharp]</p>
<p>The remaining properties and functions on the wrapper let you</p>
<ul>
<li>Force abort the consumer thread</li>
<li>Register a Finished event handler; disposing of the wrapper doesn't mean that no more work is being done. It means that you are no longer adding items and the queue is effectively "closed". Depending on your consumer function though, this could take some time to complete. This is why it's good to hook into the finished event so you can be sure that all your processing is complete.</li>
<li>Manually mark the queue as AddedComplete (so the thread stops blocking)</li>
<li>Manually cancel the queue</li>
<li>Check if the queue is ended by looking at the <code>Finished</code> property</li>
</ul>
<p>So to reiterate, the basic idea here is</p>
<ul>
<li>Create a separate thread that has appropriate exception handling to be blocked while consuming the queued items</li>
<li>Handle cancellation gracefully</li>
<li>Be able to properly end our spawned thread so we don't have anything leftover</li>
</ul>
<p>It should be noted that even though this wrapper is built for a single consumer/single producer design, since we are leveraging <code>GetConsumingEnumerable</code> we could modify the wrapper to allow for <a href="http://stackoverflow.com/questions/7528173/multiple-consumers-and-querying-a-c-sharp-blockingcollection" target="_blank" rel="noopener noreferrer">multiple threads acting as consumers</a> on the same enumerable.  This could give us a single producer/multiple synchronized consumer pattern where only one consumer thread gets the particular item but multiple consumer threads exist and can do work.</p>
<p>Full source and tests provided at our <a href="https://github.com/blinemedical/BlockingCollectionWrapper">github</a>.</p>
