---
layout: post
title: Constraint based sudoku solver
date: 2014-06-02 08:00:29.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- algorithms
- c#
- sudoku
meta:
  _edit_last: '1'
  _su_rich_snippet_type: none
  _syntaxhighlighter_encoded: '1'
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1554788393;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:2735;}i:1;a:1:{s:2:"id";i:4914;}i:2;a:1:{s:2:"id";i:3016;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2014/06/02/sudoku-solver/"
---
<p>A few weekends ago I decided to give solving <a href="http://en.wikipedia.org/wiki/Sudoku" target="_blank" rel="noopener noreferrer">Sudoku</a> a try. In case you aren't familiar with Sudoku, here is what an unsolved board looks like</p>
<p>[caption width="364" align="aligncenter"]<img src="http://onoffswitch.net/wp-content/uploads/2014/06/364px-Sudoku-by-L2G-20050714.svg_.png" width="200" height="200" class /> from wikipedia[/caption]</p>
<p>And here is a solved one</p>
<p>[caption width="364" align="aligncenter"]<img src="http://onoffswitch.net/wp-content/uploads/2014/06/364px-Sudoku-by-L2G-20050714_solution.svg_.png" width="200" height="200" class /> from wikipedia[/caption]</p>
<p>Sudoku, of size 3 is pretty easy.  Make a snapshot of the board, pick a random open cell, find out what its available possibilities are and set it to a value.   To figure out it's possibilities you need get the cells "group". This means all the values of the 3x3 cell it's in, as well as all the values of the row that it's in and the columns that it's in.  </p>
<p>Based on what is available, you can choose a number that isn't taken, plop it in down, and then recursively repeat. If nothing is available, and the board isn't empty, you messed up and the recursion will backtrack.  </p>
<p>Let's get solvin'</p>
<h2>Some helper functions</h2>
<p>Let's assume the board is a 2 dimensional nullable integer array, and that we have a class called <code>Location</code> that just encapsulates an (x,y) tuple:</p>
<p>[csharp]<br />
public int? Get(int x, int y)<br />
 {<br />
     if (x &gt; _board.Length || y &gt; _board.Length)<br />
     {<br />
         throw new Exception(&quot;invalid position&quot;);<br />
     }</p>
<p>     return _board[x, y];<br />
 }</p>
<p> public void Set(Location location, int value)<br />
 {<br />
     _board[location.X, location.Y] = value;</p>
<p>     for (int i = 0; i &lt; _emptySpaces.Count; i++)<br />
     {<br />
         if (_emptySpaces[i].X == location.X &amp;&amp; _emptySpaces[i].Y == location.Y)<br />
         {<br />
             _emptySpaces.RemoveAt(i);<br />
             return;<br />
         }<br />
     }<br />
 }<br />
[/csharp]</p>
<p>Easy enough.  Let's also keep track of empty spaces as we set things since we'll want to be able to query for empty spaces later (rather than finding them), and have a wrapper to update values of the board.</p>
<p>Now lets make sure we can get all the information regarding a cell's group. This will be relevant for our calculations. It's a lot of boring boilerplate, but here it is:</p>
<p>[csharp]<br />
public IEnumerable&lt;int&gt; UsedNumbersInSpace(Location location)<br />
 {<br />
     int x = location.X;<br />
     int y = location.Y;</p>
<p>     foreach (var item in GetCol(x, y))<br />
     {<br />
         if (item.HasValue)<br />
         {<br />
             yield return item.Value;<br />
         }<br />
     }</p>
<p>     foreach (var item in GetRow(x, y))<br />
     {<br />
         if (item.HasValue)<br />
         {<br />
             yield return item.Value;<br />
         }<br />
     }</p>
<p>     foreach (var item in GetSquare(x, y))<br />
     {<br />
         if (item.HasValue)<br />
         {<br />
             yield return item.Value;<br />
         }<br />
     }<br />
 }</p>
<p> private IEnumerable&lt;int?&gt; GetRow(int x, int y)<br />
 {<br />
     for (int i = 0; i &lt; N * N; i++)<br />
     {<br />
         yield return Get(i, y);<br />
     }<br />
 }</p>
<p> private IEnumerable&lt;int?&gt; GetCol(int x, int y)<br />
 {<br />
     for (int i = 0; i &lt; N * N; i++)<br />
     {<br />
         yield return Get(x, i);<br />
     }<br />
 }</p>
<p> private IEnumerable&lt;int?&gt; GetSquare(int x, int y)<br />
 {<br />
     int xStart = x - (x % N);<br />
     int yStart = y - (y % N);</p>
<p>     for (int i = xStart; i &lt; xStart + N; i++)<br />
     {<br />
         for (int j = yStart; j &lt; yStart + N; j++)<br />
         {<br />
             yield return Get(i, j);<br />
         }<br />
     }<br />
 }<br />
[/csharp]</p>
<h2>Solving the board</h2>
<p>Now for the fun part. Let's solve the board using a basic recursive backtracking brute force attempt:</p>
<p>[csharp]<br />
public class Solver<br />
{<br />
    public static Board Solve(Board b)<br />
    {<br />
        var nextOpen = b.NextEmpty();</p>
<p>        if (nextOpen == null)<br />
        {<br />
            return b;<br />
        }</p>
<p>        var taken = b.UsedNumbersInSpace(nextOpen);</p>
<p>        var available = b.TotalSpaceValues<br />
                         .Except(taken)<br />
                         .ToList();</p>
<p>        if (available.Count == 0)<br />
        {<br />
            return null;<br />
        }</p>
<p>        foreach (var possible in available)<br />
        {<br />
            var newBoard = b.Snapshot();</p>
<p>            newBoard.Set(nextOpen, possible);</p>
<p>            var next = Solve(newBoard);</p>
<p>            if (next != null)<br />
            {<br />
                return next;<br />
            }<br />
        }</p>
<p>        return null;<br />
    }<br />
}<br />
[/csharp]</p>
<p>Let's assume that <code>b.NextEmpty()</code> returns the first value from the <code>emptyList</code> backing collection in the board.  Basically giving you a random empty value on each iteration.  </p>
<p>That would totally work, but what happens when you move to a 4x4 board? Brute forcing it no longer really works.  The runtime of a board is n^n, where n is the number of characters.  So for a sudoku of size 3, thats a 9^9 runtime of 387420489. Shitty, but doable.  But for 4x4 now you're at 16^16 which is 18446744073709551616. Holy moly, our algorithm isn't gonna work anymore!</p>
<p>This is where a <a href="http://en.wikipedia.org/wiki/Constraint_programming" target="_blank" rel="noopener noreferrer">constraint based</a> approach would work.  Instead of just doing things as part of a single cycle (get empty spot, find available slots, put in valid piece, repeat), what if when we put in a number we also make some basic decisions and try to minimize the search space.  </p>
<ol>
<li> If a cell group only has 1 open position, fill it.  Continue to iterate through the board until the rule comes up false.  </li>
<li> After it comes up false, return the next open position who has the least amount of available items to choose from. I.e. if cell (1,1) has the possibility of being [1,2,3,4,5] and cell (5,4) has the possibility of being [1,2], return cell (5,4) as the next empty cell.  This maximizes your failure rate and means you spend less time backtracking since your decision trees are more likely to fail sooner.
</li>
</ol>
<p>It's constraint based because the moment we pin a cell that only has 1 possibility, we may have changed other parts of the board. Maybe now other spaces <em>also</em> only have one available space! We can keep going down this path until there is no more easy wins. So by choosing these values we've used some basic rules and logic to help us with our brute force search (which we still need to do when we are given too many options).</p>
<p>Given this, an easy way to tack this into the code above is to modify the <code>NextEmpty</code> function.</p>
<p>[csharp]<br />
public Location NextEmpty()<br />
{<br />
    if (_emptySpaces.Count == 0)<br />
    {<br />
        return null;<br />
    }</p>
<p>    var possibles = new Dictionary&lt;Location, List&lt;int&gt;&gt;();</p>
<p>    foreach (var emptySpace in _emptySpaces)<br />
    {<br />
        possibles[emptySpace] = TotalSpaceValues.Except(UsedNumbersInSpace(emptySpace)).ToList();</p>
<p>        if (possibles[emptySpace].Count == 1)<br />
        {<br />
            Set(emptySpace, possibles[emptySpace].First());</p>
<p>            return NextEmpty();<br />
        }<br />
    }</p>
<p>    return possibles.MinBy(kvp =&gt; kvp.Value.Count()).Key;<br />
}<br />
[/csharp]</p>
<p>So what this code does is as you call for the next empty, it tries to constrain the board when it finds a primo spot to pin.  Keeping in mind that at each solving iteration a full copy of the board is returned, its ok to mutate the board with this side effect.  As you work through sudoku on each iteration, the possible questionable space to work through minimizes and you can now reasonably solve 4x4 boards pretty quickly!</p>
<p>This is really just a C# implementation of <a href="http://norvig.com/sudoku.html">Peter Norvig's</a> sudoku solver, and if you'd like to see the full source (including the same tests that Peter Norvig used) check out my <a href="https://github.com/devshorts/Playground/tree/master/Sudoko">github</a>.</p>
