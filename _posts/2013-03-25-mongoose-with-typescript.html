---
layout: post
title: Mongoose with TypeScript
date: 2013-03-25 08:00:23.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- JavaScript
- mongoose
- typescript
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  _su_rich_snippet_type: none
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1561781734;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:3295;}i:1;a:1:{s:2:"id";i:4028;}i:2;a:1:{s:2:"id";i:3452;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2013/03/25/mongoose-with-typescript/"
---
<p>Mongoose is a library for node.js that wraps the mongoDB driver.  Since I've been playing with typescript, I wanted to show a short demo of strongly typing mongoose with unit tests run in nodeunit all using typescript.  </p>
<h2>Definitions</h2>
<p>First, I have a collection of definition files that represent mongoose types, nodeunit types, and my own document types (in schemaDef.d.ts).  </p>
<p><code>/def/all.d.ts</code></p>
<p>[ts]<br />
///&lt;reference path=&quot;./mongoose.d.ts&quot;/&gt;<br />
///&lt;reference path=&quot;./nodeUnit.d.ts&quot;/&gt;<br />
///&lt;reference path=&quot;./schemaDef.d.ts&quot;/&gt;<br />
[/ts]</p>
<p>The nodeunit definitions <code>/def/nodeUnit.d.ts</code></p>
<p>[ts]<br />
interface ITest{<br />
    done(): void;<br />
    ok(isGood:Boolean, message?:string):void;<br />
    equal(expected:any, actual:any, message?:string);<br />
}<br />
[/ts]</p>
<p>Here are the basic mongoose definitions in <code>/def/mongoose.d.ts</code>.  I can't guarantee that these types are right, I'm updating them as I go along.  I'm inferring the structure from the documentation and personal experimentation.  As I encounter new mongoose definitions, I can just add them to the appropriate scope.  You can see that I'm also chaining definitions: one definitions functions might return another interface that has other definitions.  This makes it really easy to model the fluent api that mongoose exposes.</p>
<p>[ts]<br />
interface ICallback{<br />
    callback(error:string, item:any): void;<br />
}</p>
<p>interface IEmptyCallback{<br />
    callback() : void;<br />
}</p>
<p>interface IErrorCallback{<br />
    callback(item:string) : void;<br />
}</p>
<p>interface IWhere{<br />
    equals(value:String):IChainable;<br />
    gt(value:String):IChainable;<br />
    lt(value:String):IChainable;<br />
    in(value:String[]):IChainable;<br />
}</p>
<p>interface IChainable{<br />
    exec(item:ICallback) : IChainable;<br />
    populate(...args: any[]) : IChainable;<br />
    select(query:string):IChainable;<br />
    limit(num:Number):IChainable;<br />
    sort(field:String):IChainable;<br />
    where(selector:String):IWhere;<br />
}</p>
<p>interface IMongooseSearchable{<br />
    findOne(item:any, callback:ICallback) : void;<br />
    find(id:string, callback?:ICallback) : IChainable;<br />
    find(propBag:Object, callback?:ICallback) : IChainable;<br />
    remove(item:any, callback:IErrorCallback) : void;<br />
}</p>
<p>interface IMongooseBase {<br />
    save(item: IEmptyCallback) : void;<br />
    push(item:IMongooseBase):void;<br />
}<br />
[/ts]</p>
<p>Here is my test schema definition <code>/def/schema.d.ts</code>.  Just for the example I only have a user with a name and an id.</p>
<p>[ts]<br />
interface IUser extends IMongooseBase{<br />
    _id: string;<br />
    name: string;<br />
}<br />
[/ts]</p>
<h2>Modeling the Schema</h2>
<p>First, I need to model the schema using mongoose.  I have a couple of run once variables that are part of the module export. These are things that are not enclosed with an export tag.  They're not global since CommonJS encapsulates everything in a module, but they will run once when the module is created.  This makes it easier to reference in the dbclass.  </p>
<p>To create data with mongoose you need to first instantiate a schema with a property bag. This gives you an instance that you pass to the mongoose model function. The model function gives you a function reference back that you can use to create new model objects.  Since we need to be able to new up objects, we can cast it to an anonymous object that has a <code>new()</code> function that returns the correct type we want (IUser).  Thanks to Bill Ticehurst for answering <a href="http://stackoverflow.com/a/15399536/310196" target="_blank" rel="noopener noreferrer">my question</a> regarding how this is done. The target type for the user function reference is of <code>IMongooseSearchable</code> because we'll be able to do searching/querying on that model using this.  </p>
<p>I've also wrapped the creation of a new user in a helper function that does the appropriate casting that I need. This way, later, I can just call "db.newUser()" to create a new model object without having to worry about casting outside of the db class.</p>
<p>[ts]<br />
///&lt;reference path='../def/all.ts'/&gt;<br />
var mongoose:any = require(&quot;mongoose&quot;);</p>
<p>// Need to provide the same structure in 'mongoose' style format to define.<br />
var userSchema = new mongoose.Schema(<br />
    {<br />
       name: String<br />
    });</p>
<p>export var User:IMongooseSearchable = &lt;{ new() : IUser; }&gt;mongoose.model('User', userSchema);</p>
<p>export class db{<br />
    init(dbName:string, ignoreFailures:bool){<br />
        if(dbName == null){<br />
            dbName = &quot;test&quot;;<br />
        }</p>
<p>        try{<br />
            mongoose.connect('localhost', dbName);<br />
        }<br />
        catch(e){<br />
            if(!ignoreFailures){<br />
                throw e;<br />
            }<br />
        }<br />
    }</p>
<p>    disconnect(){<br />
        mongoose.disconnect();<br />
    }</p>
<p>    newUser():IUser{<br />
        return &lt;IUser&gt;new User();<br />
    }<br />
}<br />
[/ts]</p>
<h2>Testing</h2>
<p>And now to test it all with with NodeUnit.  Tests are run top to bottom so we can create a test fixture setup as the first function. The downside to this is that it counts as a test itself, but the upside is that we can do a single setup and teardown per group.  NodeUnit lets you define setup and teardown for each test as well (but I'm not showing it here) by exposing <code>setUp</code> and <code>tearDown</code> methods on your exported group object.</p>
<p>As an example, my one query test shows a mongoose save, basic find, and a more complex find with a filter.  Notice that the user object has a save method on it (because it inherits from <code>IMongooseBase</code>, but to query the users we have to reference the function that was given to us by mongoose that represents the schema.  From typescripts perspective though, this is all strongly typed since we've hidden away the casting and weirdness inside of the db class. </p>
<p>I've also used the definitions I made for nodeunit to get a strongly typed nodeunit test object.  If I needed more properties for assertions I could add them to the definitions file and they'd be available in typescript for me.</p>
<p>[ts]<br />
///&lt;reference path=&quot;../def/all.d.ts&quot;/&gt;<br />
///&lt;reference path=&quot;../storage/schema.ts&quot;/&gt;</p>
<p>import schema = module(&quot;../storage/schema&quot;);</p>
<p>var storage = new schema.db();</p>
<p>export var group = {<br />
    init: (t:ITest) =&gt;{<br />
        storage.init(&quot;test&quot;);<br />
        t.done();<br />
    },</p>
<p>    test: (t:ITest) =&gt;{<br />
        var u = storage.newUser();</p>
<p>        u.name = &quot;test&quot;;</p>
<p>        u.save(()=&gt; {<br />
            schema.User.findOne(u._id, (err, user) =&gt; {<br />
                console.log(user.name);</p>
<p>                schema.User.find(u._id)<br />
                    .where(&quot;_id&quot;).equals(u._id)<br />
                    .exec((err, u1) =&gt; {<br />
                        console.log(u1);</p>
<p>                        t.equal(u1[0].name, u.name);<br />
                        t.done();<br />
                    });<br />
            });<br />
        });<br />
    },</p>
<p>    end: (t:ITest) =&gt;{<br />
        storage.disconnect();<br />
        t.done();<br />
    }<br />
}<br />
[/ts]</p>
<h2>Conclusion</h2>
<p>When working with typescript I found myself frequently checking the compiled javascript to make sure it's what I actually wanted it to be. I found this to workflow to work well when using code that you are typing yourself.  This way you can validate that what is compiled makes sense.</p>
<h2>edit:</h2>
<p>My schema def's have changed since the posting of this post: for my up to date mongoose schema definitions check my <a href="https://github.com/devshorts/trakkit/blob/master/def/mongoose.d.ts">github</a></p>
