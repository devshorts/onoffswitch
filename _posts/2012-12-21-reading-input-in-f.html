---
layout: post
title: Reading input in F#
date: 2012-12-21 15:35:59.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
- Imported
tags: []
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  dsq_thread_id: '986440027'
  _su_title: ''
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1559832280;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:3565;}i:1;a:1:{s:2:"id";i:4365;}i:2;a:1:{s:2:"id";i:4028;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2012/12/21/reading-input-in-f/"
---
<p><em>This article was originally published at <a href="http://tech.blinemedical.com/reading-input-in-f/" target="_blank" rel="noopener noreferrer">tech.blinemedical.com</a></em></p>
<p>I've been playing with F# lately, much to the the chagrin of <a href="http://tech.blinemedical.com/author/samuel-neff/" target="_blank" rel="noopener noreferrer">Sam</a>, but I still think it's fun as an excersize in thinking differently. I also find its terseness lets you prototype ideas quickly, encouraging you to experiment and tweak your code. However, I'm much more used to imperative programming, so when I started writing an F# program that needed user input I hit a small roadblock: how do I get input, validate, and ask for it again if I want to stay purely functional and leverage immutable values?</p>
<p>In an imperative language you might write something like this:</p>
<p>[csharp]<br />
String path = null;<br />
while(true)<br />
{<br />
    path = Console.ReadLine();<br />
    if (File.Exists(path))<br />
    {<br />
        break;<br />
    }</p>
<p>    Console.WriteLine(&quot;File doesn't exist&quot;);<br />
}<br />
[/csharp]</p>
<p>You can't declare <code>path</code> inside the while loop or its loses its scope. If you need to use <code>path</code> outside of the while loop, then it might seem like you have to let path be mutable. But, what if we did this:</p>
<p>[csharp]<br />
private String GetPath()<br />
{<br />
    while(true)<br />
    {<br />
        var path = Console.ReadLine();<br />
        if (File.Exists(path))<br />
        {<br />
            return path;<br />
        }<br />
        Console.WriteLine(&quot;File doesn't exist&quot;);<br />
    }<br />
}<br />
[/csharp]</p>
<p>Now we don't ever update any variables. We only ever use direct assignment. This sounds pretty functional to me. But, we still can't directly translate into F#. Remembering that in F# the last statement is the return value, what does this return?</p>
<p>[csharp]<br />
let falseItem =<br />
    while true do<br />
        false<br />
[/csharp]</p>
<p>This is actually an infinite loop; the while loop won't ever return <code>false</code>. In F#, a while loop can't return from it's body, since the body expression return type <a href="http://msdn.microsoft.com/en-us/library/dd233208.aspx" target="_blank" rel="noopener noreferrer">has to be</a> of type unit. If you imagine the while loop as a function that takes a predicate and a lambda for the body then this makes sense. The <code>whileLoop</code> function will execute the body as long as the predicate returns true. So, in psuedocode, it kind of looks like this</p>
<p>[csharp]<br />
whileLoop(predicate, body) = {<br />
  while predicate() do {<br />
     body()<br />
  }<br />
}<br />
[/csharp]</p>
<p>Now what? Well, turning this while loop into a recursive structure with immutable types is actually pretty easy:</p>
<p>[csharp]<br />
let rec documentPath =<br />
    fun () -&gt;<br />
        Console.Write(&quot;File path: &quot;)<br />
        let path = Console.ReadLine()<br />
        if not(File.Exists path) then<br />
            Console.WriteLine(&quot;File does not exist&quot;)<br />
            documentPath()<br />
        else path<br />
[/csharp]</p>
<p>The trick here is to define <code>documentPath</code> as a recursive function. Either the function returns a valid path, or it calls itself executing the next "step" in our while loop. Also, since we don't need to do any work after the recursive function call, F# can optimize this to use <a href="http://stackoverflow.com/questions/310974/what-is-tail-call-optimization" target="_blank" rel="noopener noreferrer">tail call optimization</a>. The <code>documentPath</code> variable is of type <code>unit -&gt; string</code> meaning it's a function that takes a unit type and returns a string. To actually get the path, we execute <code>documentPath()</code>, where <code>()</code> is the unit type.</p>
<p>Now we have a function that uses immutable types, but continuously reads in user input and won't return until the input is valid.</p>
<p>Though, if you really want to use imperative style loop breaks, <a href="http://tomasp.net/blog/imperative-i-return.aspx" target="_blank" rel="noopener noreferrer">you can</a>, but it's not trivial.</p>
