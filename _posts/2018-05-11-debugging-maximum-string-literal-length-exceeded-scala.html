---
layout: post
title: Debugging "Maximum String literal length exceeded" with scala
date: 2018-05-11 01:02:19.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- bug
- scala
meta:
  _edit_last: '1'
  _wpcom_is_markdown: '1'
  _su_rich_snippet_type: none
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1560002911;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:2735;}i:1;a:1:{s:2:"id";i:4862;}i:2;a:1:{s:2:"id";i:4068;}}}}
  _syntaxhighlighter_encoded: '1'
  _wpas_done_all: '1'
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2018/05/11/debugging-maximum-string-literal-length-exceeded-scala/"
---
<p>Today I ran into a fascinating bug.  We use <a href="https://github.com/iheartradio/ficus">ficus</a> as a HOCON auto parser for scala. It works great, because parsing configurations into strongly typed case classes is annoying. Ficus works by using a macro to invoke implicitly in scope <code>Reader[T]</code> classes for data types and recursively builds the nested parser.</p>
<p>I went to create a test for a new custom field I added to our config:</p>
<p>[scala]<br />
class ProductConfigTests extends FlatSpec {<br />
  &quot;Configs&quot; should &quot;be valid in QA&quot; in {<br />
    assert(ConfigLoader.verify(ProductsConfig, Environment.QA).isSuccess)<br />
  }<br />
}<br />
[/scala]</p>
<p>Our config verifier just invokes the hocon parser and makes sure it doesn't throw an error. <code>ProductsConfig</code> has a lot of fields to it, and I recently added a new one.  Suddenly the test broke with the following error:</p>
<p>[code]<br />
error] Error while emitting com/services/products/service/tests/ConfigTests<br />
[error] Maximum String literal length exceeded<br />
[error] one error found<br />
[error] (server/test:compileIncremental) Compilation failed<br />
[error] Total time: 359 s, completed May 10, 2018 4:56:02 PM<br />
> test:compile<br />
[info] Compiling 36 Scala sources to /Users/antonkropp/src/products/server/target/scala-2.12/test-classes...<br />
java.lang.IllegalArgumentException: Maximum String literal length exceeded<br />
	at scala.tools.asm.ByteVector.putUTF8(ByteVector.java:213)<br />
	at scala.tools.asm.ClassWriter.newUTF8(ClassWriter.java:1114)<br />
	at scala.tools.asm.ClassWriter.newString(ClassWriter.java:1582)<br />
	at scala.tools.asm.ClassWriter.newConstItem(ClassWriter.java:1064)<br />
	at scala.tools.asm.MethodWriter.visitLdcInsn(MethodWriter.java:1187)<br />
	at scala.tools.asm.tree.LdcInsnNode.accept(LdcInsnNode.java:71)<br />
	at scala.tools.asm.tree.InsnList.accept(InsnList.java:162)<br />
	at scala.tools.asm.tree.MethodNode.accept(MethodNode.java:820)<br />
	at scala.tools.asm.tree.MethodNode.accept(MethodNode.java:730)<br />
[/code]</p>
<p>Wat?</p>
<p>I fired up <code>sbt -jvm-debug 5005</code> and attached to the compiler.</p>
<p><img src="http://onoffswitch.net/wp-content/uploads/2018/05/maxstring1.png" alt="" width="1705" height="660" class="aligncenter size-full wp-image-4992" /></p>
<p>I can def see that there is some sort of class being written with a large const string. But why?  I'd never seen this before.</p>
<p>I went to another service that has a test exactly like this for its config and used <a href="http://www.benf.org/other/cfr/">cfr</a> to decompile the generated scala files:</p>
<p>[code]<br />
antonkropp at combaticus in ~/src/curalate/queue-batcher/server/target/scala-2.12/test-classes/com/curalate/services/queuebatcher/service/tests (devx/minimize-io-calls)<br />
$ ls<br />
total 1152<br />
-rw-r--r--  1 antonkropp  staff   47987 May 10 11:20 BatchTrackerTests.class<br />
-rw-r--r--  1 antonkropp  staff  145293 May 10 13:34 BitGroupTests.class<br />
-rw-r--r--  1 antonkropp  staff    3112 May  9 13:23 ConfigTests$$anon$1$$anon$2$$anon$3.class<br />
-rw-r--r--  1 antonkropp  staff    3553 May  9 13:23 ConfigTests$$anon$1$$anon$2$$anon$4$$anon$5.class<br />
-rw-r--r--  1 antonkropp  staff    5190 May  9 13:23 ConfigTests$$anon$1$$anon$2$$anon$4.class<br />
-rw-r--r--  1 antonkropp  staff    3627 May  9 13:23 ConfigTests$$anon$1$$anon$2$$anon$6.class<br />
-rw-r--r--  1 antonkropp  staff    3906 May  9 13:23 ConfigTests$$anon$1$$anon$2.class<br />
-rw-r--r--  1 antonkropp  staff    4904 May  9 13:23 ConfigTests$$anon$1$$anon$7.class<br />
-rw-r--r--  1 antonkropp  staff    4598 May  9 13:23 ConfigTests$$anon$1$$anon$8.class<br />
-rw-r--r--  1 antonkropp  staff    5063 May  9 13:23 ConfigTests$$anon$1.class<br />
-rw-r--r--  1 antonkropp  staff    3125 May  9 13:23 ConfigTests$$anon$17$$anon$18$$anon$19.class<br />
-rw-r--r--  1 antonkropp  staff    3573 May  9 13:23 ConfigTests$$anon$17$$anon$18$$anon$20$$anon$21.class<br />
-rw-r--r--  1 antonkropp  staff    5213 May  9 13:23 ConfigTests$$anon$17$$anon$18$$anon$20.class<br />
-rw-r--r--  1 antonkropp  staff    3640 May  9 13:23 ConfigTests$$anon$17$$anon$18$$anon$22.class<br />
-rw-r--r--  1 antonkropp  staff    3924 May  9 13:23 ConfigTests$$anon$17$$anon$18.class<br />
-rw-r--r--  1 antonkropp  staff    4914 May  9 13:23 ConfigTests$$anon$17$$anon$23.class<br />
-rw-r--r--  1 antonkropp  staff    4606 May  9 13:23 ConfigTests$$anon$17$$anon$24.class<br />
-rw-r--r--  1 antonkropp  staff    5073 May  9 13:23 ConfigTests$$anon$17.class<br />
-rw-r--r--  1 antonkropp  staff    3119 May  9 13:23 ConfigTests$$anon$9$$anon$10$$anon$11.class<br />
-rw-r--r--  1 antonkropp  staff    3566 May  9 13:23 ConfigTests$$anon$9$$anon$10$$anon$12$$anon$13.class<br />
-rw-r--r--  1 antonkropp  staff    5205 May  9 13:23 ConfigTests$$anon$9$$anon$10$$anon$12.class<br />
-rw-r--r--  1 antonkropp  staff    3634 May  9 13:23 ConfigTests$$anon$9$$anon$10$$anon$14.class<br />
-rw-r--r--  1 antonkropp  staff    3915 May  9 13:23 ConfigTests$$anon$9$$anon$10.class<br />
-rw-r--r--  1 antonkropp  staff    4909 May  9 13:23 ConfigTests$$anon$9$$anon$15.class<br />
-rw-r--r--  1 antonkropp  staff    4601 May  9 13:23 ConfigTests$$anon$9$$anon$16.class<br />
-rw-r--r--  1 antonkropp  staff    5066 May  9 13:23 ConfigTests$$anon$9.class<br />
-rw-r--r--  1 antonkropp  staff   87180 May  9 13:23 ConfigTests.class<br />
-rw-r--r--  1 antonkropp  staff   69451 May  9 13:23 DbTests.class<br />
-rw-r--r--  1 antonkropp  staff   12985 May  9 13:23 MysqlTests.class<br />
-rw-r--r--  1 antonkropp  staff   68418 May 10 12:40 Tests.class<br />
drwxr-xr-x  4 antonkropp  staff     128 May  9 13:23 db<br />
drwxr-xr-x  9 antonkropp  staff     288 May  9 13:23 modules</p>
<p>$ java -jar ~/tools/cfr.jar ConfigTests.class<br />
[/code]</p>
<p>1000 lines later, I can see</p>
<p><img src="http://onoffswitch.net/wp-content/uploads/2018/05/maxstring2.png" alt="" width="1203" height="556" class="aligncenter size-full wp-image-4996" /></p>
<p>So something is putting in a large string of the configuration parser compiled into the class file.</p>
<p>I checked the ficus source code and its not it, so it must be something with the test.</p>
<p>Turns out <code>assert</code> is a macro from scalatest:</p>
<p>[scala]<br />
def assert(condition: Boolean)(implicit prettifier: Prettifier, pos: source.Position): Assertion = macro AssertionsMacro.assert<br />
[/scala]</p>
<p>Where the macro<br />
[scala]<br />
def assert(context: Context)(condition: context.Expr[Boolean])(prettifier: context.Expr[Prettifier], pos: context.Expr[source.Position]): context.Expr[Assertion] =<br />
    new BooleanMacro[context.type](context, &quot;assertionsHelper&quot;).genMacro[Assertion](condition, &quot;macroAssert&quot;, context.literal(&quot;&quot;), prettifier, pos)</p>
<p>[/scala]<br />
Is looking for an implicit position.</p>
<p>Position is from scalactic which comes with scalatest</p>
<p>[scala]<br />
case class Position(fileName: String, filePathname: String, lineNumber: Int)</p>
<p>/**<br />
 * Companion object for &lt;code&gt;Position&lt;/code&gt; that defines an implicit<br />
 * method that uses a macro to grab the enclosing position.<br />
 */<br />
object Position {</p>
<p>  import scala.language.experimental.macros</p>
<p>  /**<br />
   * Implicit method, implemented with a macro, that returns the enclosing<br />
   * source position where it is invoked.<br />
   *<br />
   * @return the enclosing source position<br />
   */<br />
  implicit def here: Position = macro PositionMacro.genPosition<br />
}<br />
[/scala]</p>
<p>And here we can ascertain that the macro expansion of the ficus config parser is being captured by the position file macro and auto compiled into the <em>assert</em> statement!</p>
<p>Changing the test to be</p>
<p>[scala]<br />
class ProductConfigTests extends FlatSpec {<br />
  &quot;Configs&quot; should &quot;be valid in QA&quot; in {<br />
    validate(ConfigLoader.verify(ProductsConfig, Environment.QA).isSuccess)<br />
  }</p>
<p>  /**<br />
   * This validate function needs to exist because this bug is amazing.<br />
   *<br />
   * `assert` is a macro from scalatest that automatically compiles the contextual source tree<br />
   * into the assert, so that you can get line number and metadata context if the line fails.<br />
   *<br />
   * The ficus macro expander for ProductConfig is larger than 65k characters, which is normally fine<br />
   * for code, however since scalatest tries to compile this &gt; 65k anonymous class tree as a _string_<br />
   * it breaks the java compiler!<br />
   *<br />
   * By breaking the function scope and having the macro create a closure around the _validate_ block<br />
   * it no longer violates the 65k static string constraint<br />
   */<br />
  private def validate(block: =&gt; Boolean): Unit = {<br />
    assert(block)<br />
  }<br />
}<br />
[/scala]</p>
<p>Now makes the test pass.  What a day.</p>
