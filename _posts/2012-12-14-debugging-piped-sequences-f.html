---
layout: post
title: Debugging piped operations in F#
date: 2012-12-14 09:34:27.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
- Imported
tags:
- Debugging
- F#
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  dsq_thread_id: '963156174'
  _su_title: ''
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1559527959;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:2735;}i:1;a:1:{s:2:"id";i:3565;}i:2;a:1:{s:2:"id";i:4197;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2012/12/14/debugging-piped-sequences-f/"
---
<p><em>This article was originally published at <a href="http://tech.blinemedical.com/debugging-piped-sequences-f/" target="_blank" rel="noopener noreferrer">tech.blinemedical.com</a></em></p>
<h1>A little on the pipe operator</h1>
<p>In F# you can create <a href="http://www.c-sharpcorner.com/uploadfile/rmcochran/fsharp-types-and-the-forward-pipe-operator/" target="_blank" rel="noopener noreferrer">piped operations</a> using the <code><a href="http://msdn.microsoft.com/en-us/library/dd233229.aspx" target="_blank" rel="noopener noreferrer">|&gt;</a></code> operator. This takes the output of the previous statement and funnels it as the input to the next statement. Using the pipe operator, a statement like this:</p>
<p>[fsharp]<br />
x |&gt; f |&gt; g |&gt; h<br />
[/fsharp]</p>
<p>Means having functions nested like this:</p>
<p>[fsharp]<br />
h(g(f(x))<br />
[/fsharp]</p>
<p>So a piece of code like this:</p>
<p>[fsharp]<br />
let print item = Console.WriteLine(item.ToString)</p>
<p>let seqDebug =<br />
        [0..1000]<br />
                |&gt; List.map (fun i -&gt; i + 1)<br />
                |&gt; List.filter (fun i -&gt; i &lt; 5)<br />
                |&gt; List.head<br />
                |&gt; print<br />
[/fsharp]</p>
<p>Decompiles into this (formatting added):</p>
<p>[csharp]<br />
[DebuggerBrowsable(DebuggerBrowsableState.Never)]<br />
internal static Unit seqDebugu00407;</p>
<p>public static void mainu0040()<br />
{<br />
    Program.print(<br />
        ListModule.Head(<br />
            ListModule.Filter((FSharpFunc&lt;int, bool&gt;) new Program.seqDebugu004010(),<br />
                ListModule.Map&lt;int, int&gt;((FSharpFunc&lt;int, int&gt;) new Program.seqDebugu00409u002D1(),<br />
                    SeqModule.ToList(Operators.CreateSequence(<br />
                        Operators.OperatorIntrinsics.RangeInt32(0, 1, 1000)))))));</p>
<p>    u0024Program.seqDebugu00407 = (Unit) null;<br />
}<br />
[/csharp]</p>
<p>Which really boils down to:</p>
<p>[csharp]<br />
seqDebug = Print(Head(Filter(Map(sequence))))<br />
[/csharp]</p>
<p>The F# syntax is nice because it lets us write code from the outside in, instead of inside out.</p>
<h1>Debugging it</h1>
<p>Now that we know what F# is doing, lets say we want to debug the print statement. You can't use your normal "<a href="http://msdn.microsoft.com/en-us/library/ek13f001.aspx" target="_blank" rel="noopener noreferrer">Step Over</a>" F10 key to go through your piped statement here because it compiles down to a one line group of nested functions. We could use the "Step Into" key (F11) to step into the entire sequence but then we have to execute the anonymous map lambda 1001 times just to get to the next statement. Then another 1001 for the filter. Then the head statement, and finally, our print. No thanks.</p>
<p>Thankfully, Visual Studio has thought of this and you can use the <em><a href="http://msdn.microsoft.com/en-us/library/7ad07721.aspx" target="_blank" rel="noopener noreferrer">Step Into Specific</a></em> functionality. This lets you see the list of nested functions at that line and you can jump into whatever you need to here. <i>Step Into Specific</i> isn't an F# only feature, but I never realized it existed until I ran into this scenario.</p>
<p><a href="http://tech.blinemedical.com/wp-content/uploads/2012/12/stepIntoSpecific2.png"><img class="aligncenter size-medium wp-image-1954" alt="Step into Specific " src="http://tech.blinemedical.com/wp-content/uploads/2012/12/stepIntoSpecific2-300x105.png" width="300" height="105" /></a></p>
<p>The example is a little trivial, since you would've just put a breakpoint in the print statement, right? But what if you are piping through F# operators like <code>List.map</code> and <code>List.filter</code>? In these cases it can be hard to know what is the direct input to these functions since the input argument is automatically applied. For these scenarios, a simple identity function can be really helpful:</p>
<p>[fsharp]<br />
let identity item = item</p>
<p>let seqDebug =<br />
        [0..1000]<br />
                |&gt; List.map (fun i -&gt; i + 1)<br />
                |&gt; identity<br />
                |&gt; List.filter (fun i -&gt; i &lt; 5)<br />
                |&gt; List.head<br />
[/fsharp]</p>
<p>So you can sprinkle in your identity function and put breakpoints there. This way you can inject yourself into the middle of this sequence.</p>
<h1>Piping with functions that return unit</h1>
<p>Taking this one step further, sometimes I want to print out a value in the middle of the sequence, or call a function that has a return type of <code>unit</code> but continue piping. Because let's be honest here, when all else fails nothing beats a well placed <code>printf</code> in your code. But, we're left with a small dilemma: since pipes take the output of the last function and use it as the input to the next function we can't really use print statements. Both <code>printf</code> and <code>Console.WriteLine</code> effectively return a <code>void</code>. Putting them in the middle of a chain won't work since their output won't map to the next functions input (unless that next function takes <code>unit</code>).</p>
<p>However, F# lets you define <a href="http://msdn.microsoft.com/en-us/library/dd233204.aspx" target="_blank" rel="noopener noreferrer">your own operators</a>, so I created one that I like to call the "argument identity" that executes a function which returns void and then returns the original argument (acting as an argument identity function):</p>
<p>[fsharp]<br />
let (~~) (func:'a-&gt; unit) (arg:'a) = (func arg) |&gt; fun () -&gt; arg<br />
[/fsharp]</p>
<p>The <code>~~</code> symbol is a <a href="http://msdn.microsoft.com/en-us/library/dd233204.aspx" target="_blank" rel="noopener noreferrer">prefix</a> operator that takes a function of one argument that returns unit, then closes the argument into a function with type <code>unit -&gt; 'a</code>. Then I pipe the return value (unit) to the anonymous function (that takes unit) which will return the closed value of the original argument. Now I can do things like this:</p>
<p>[fsharp]<br />
let (~~) (func:'a-&gt; unit) (arg:'a) = (func arg) |&gt; fun () -&gt; arg</p>
<p>let seqDebug =<br />
        [0..1000]<br />
                |&gt; List.map (fun i -&gt; i + 1)<br />
                |&gt; ~~ Console.WriteLine<br />
                |&gt; List.filter (fun i -&gt; i &lt; 3)<br />
                |&gt; ~~ Console.WriteLine<br />
                |&gt; List.head<br />
                |&gt; ~~ Console.WriteLine<br />
[/fsharp]</p>
<p>Which prints out</p>
<p>[csharp]<br />
[1; 2; 3; ... ]<br />
[1; 2]<br />
1<br />
[/csharp]</p>
<p>You obviously don't need your own operator, you can make it a named helper function if you want. Either way, some sort of argument identity function is useful in these scenarios.</p>
<h1>Disassemble the pipe</h1>
<p>And of course, when all else fails, you can break up the sequence into a series of <code>let</code> statements to debug it the old fashioned way.</p>
<p>[fsharp]<br />
let seqDebugDecomposed =<br />
        let source = [0..1000]<br />
        let sourcePlusOne = List.map (fun i -&gt; i + 1) source<br />
        let filteredSource = List.filter (fun i -&gt; i &lt; 3) sourcePlusOne<br />
        let listHead = List.head filteredSource<br />
        print listHead<br />
[/fsharp]</p>
