---
layout: post
title: Avoiding nulls with expression trees
date: 2014-04-04 04:23:28.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- ast
- c#
- expression tree
- 'null'
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  _su_rich_snippet_type: none
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1561472234;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:2735;}i:1;a:1:{s:2:"id";i:3779;}i:2;a:1:{s:2:"id";i:4862;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2014/04/04/avoiding-nulls-expression-trees/"
---
<p>I've blogged about this subject <a href="http://onoffswitch.net/minimizing-null-ref/" target="_blank" rel="noopener noreferrer">before</a>, but I REALLY hate null refs.  This is one of the reasons I love F# and other functional languages, null ref's almost never happen. But, in the real world I work as a C# dev and have to live with C#'s... nuisances.  </p>
<p>In the other post, a big problem with the dynamic proxy was that it only worked with virtual methods, so it wasn't really all that practical. This time around I decided to try a different route and leverage expression tree's to actually build out the if checks automatically.</p>
<p>For the impatient, full source available at my <a href="https://github.com/devshorts/MonadicNull" target="_blank" rel="noopener noreferrer">github </a>and the library is available on <a href="https://www.nuget.org/packages/Devshorts.MonadicNull/0.2.1" target="_blank" rel="noopener noreferrer">nuget</a></p>
<h2>Demonstration</h2>
<p>Let me demonstrate the final usage first.  If all of users properties and methods return null, executing this whole chain would fail starting at the null result of <code>GetSchool()</code>. But, by using the Option static class we can safely deconstruct and inspect the expression, returning if the chain is valid, what failed in it, and what was the final value (if one existed).</p>
<p>[csharp]<br />
public void TestGetSafe()<br />
{<br />
    var user = new User();</p>
<p>    MethodValue&lt;string&gt; name = Option.Safe(() =&gt; user.GetSchool().District.Street.Name);</p>
<p>    Assert.IsFalse(name.ValidChain());<br />
}<br />
[/csharp]</p>
<p>The lambda is converted to an expression tree and rebuilt into this glorious mess:</p>
<p>[code]<br />
.Lambda #Lambda1&lt;System.Func`2[NoNulls.Tests.SampleData.User,Devshorts.MonadicNull.MethodValue`1[System.String]]&gt;(NoNulls.Tests.SampleData.User $u)<br />
{<br />
    .Block() {<br />
        .Block(NoNulls.Tests.SampleData.User $var1) {<br />
            $var1 = $u;<br />
            .If ($var1 == null) {<br />
                .New Devshorts.MonadicNull.MethodValue`1[System.String](<br />
                    null,<br />
                    &quot;u&quot;,<br />
                    False)<br />
            } .Else {<br />
                .Block(NoNulls.Tests.SampleData.School $var2) {<br />
                    $var2 = .Call $var1.GetSchool();<br />
                    .If ($var2 == null) {<br />
                        .New Devshorts.MonadicNull.MethodValue`1[System.String](<br />
                            null,<br />
                            &quot;u.GetSchool()&quot;,<br />
                            False)<br />
                    } .Else {<br />
                        .Block(NoNulls.Tests.SampleData.District $var3) {<br />
                            $var3 = $var2.District;<br />
                            .If ($var3 == null) {<br />
                                .New Devshorts.MonadicNull.MethodValue`1[System.String](<br />
                                    null,<br />
                                    &quot;u.GetSchool().District&quot;,<br />
                                    False)<br />
                            } .Else {<br />
                                .Block(NoNulls.Tests.SampleData.Street $var4) {<br />
                                    $var4 = $var3.Street;<br />
                                    .If ($var4 == null) {<br />
                                        .New Devshorts.MonadicNull.MethodValue`1[System.String](<br />
                                            null,<br />
                                            &quot;u.GetSchool().District.Street&quot;,<br />
                                            False)<br />
                                    } .Else {<br />
                                        .Block(System.String $var5) {<br />
                                            $var5 = $var4.Name;<br />
                                            .New Devshorts.MonadicNull.MethodValue`1[System.String](<br />
                                                $var5,<br />
                                                &quot;u.GetSchool().District.Street.Name&quot;,<br />
                                                True)<br />
                                        }<br />
                                    }<br />
                                }<br />
                            }<br />
                        }<br />
                    }<br />
                }<br />
            }<br />
        }<br />
    }<br />
}<br />
[/code]</p>
<p>The return value of the <code>Safe</code> method is a new object called <code>MethodValue<t /></code> which tells you if the expression was successful (i.e. no nulls), or if it did fail, <em>what</em> failed (i.e. where in the expression it failed).  And of course if the chain is valid you can get the value safely.</p>
<h2>The magic</h2>
<p>The magic is actually pretty easy.  Because we have access to the expression tree we can rewrite it however we want.  If you aren't familiar with expression trees, the idea is that the compiler can convert a lambda into it's abstract syntax tree. That means you can traverse it (with a visitor) and know information about the objects.</p>
<p>Since we need to know the information about the whole call chain we need to iterate over it all first.  As we iterate we should track of what happened in the call chain so we can re-iterate over it later and manipulate it at the end.</p>
<p>[csharp]<br />
private readonly Stack&lt;Expression&gt; _expressions = new Stack&lt;Expression&gt;();</p>
<p>private Expression _finalExpression;</p>
<p>private void CaptureFinalExpression(Expression node)<br />
{<br />
    if (_finalExpression == null)<br />
    {<br />
        _finalExpression = node;<br />
    }<br />
}</p>
<p>protected override Expression VisitLambda&lt;Y&gt;(Expression&lt;Y&gt; node)<br />
{<br />
    base.Visit(node.Body);</p>
<p>    CaptureFinalExpression(node.Body);</p>
<p>    if (node.Parameters.Count &gt; 0)<br />
    {<br />
        _expressions.Push(node.Parameters.First());</p>
<p>        var final = BuildFinalStatement();</p>
<p>        return Expression.Lambda(final, node.Parameters);<br />
    }</p>
<p>    return Expression.Lambda(BuildFinalStatement());<br />
}</p>
<p>protected override Expression VisitMethodCall(MethodCallExpression node)<br />
{<br />
    _expressions.Push(node);</p>
<p>    return Visit(node.Object);<br />
}</p>
<p>protected override Expression VisitMember(MemberExpression node)<br />
{<br />
    _expressions.Push(node);</p>
<p>    return Visit(node.Expression);<br />
}<br />
[/csharp]</p>
<p>In the process of visiting the nodes, we pushed each piece of the call chain into a stack.  Now we can build it all back out. The bulk of the work is in this recursive function. It iterates back through the stack, maps the previous call to a variable, and builds out if not null checks.</p>
<p>[csharp]<br />
private Expression BuildIfs(Expression current, Expression prev = null)<br />
{<br />
    var stringRepresentation = Expression.Constant(current.ToString(), typeof(string));</p>
<p>    var variable = Expression.Parameter(current.Type, NextVarName);</p>
<p>    Expression evaluatedExpression = EvaluateExpression(current, prev);</p>
<p>    var assignment = Expression.Assign(variable, evaluatedExpression);</p>
<p>    var end = _expressions.Count == 0;</p>
<p>    var nextExpression =<br />
         !end<br />
            ? BuildIfs(_expressions.Pop(), variable)<br />
            : LastExpression(variable, stringRepresentation);</p>
<p>    Expression blockBody;</p>
<p>    if (!end)<br />
    {<br />
        var whenNull = OnNull(stringRepresentation);</p>
<p>        blockBody = CheckForNull(variable, whenNull, nextExpression);<br />
    }<br />
    else<br />
    {<br />
        blockBody = nextExpression;<br />
    }</p>
<p>    return Expression.Block(new [] { variable }, new[] { assignment, blockBody });<br />
}<br />
[/csharp]</p>
<p>When I say "map the previous call" I mean building out something like this:</p>
<p>[csharp]<br />
var var1 = user;<br />
if(var1 != null){<br />
   var var2 = var1.school</p>
<p>   if(var2 != null)<br />
   ....<br />
}<br />
[/csharp]</p>
<p>The initial statement "user" needs to get assigned to a variable. Then this variable needs to be transformed into a new call where we call ".school" on it. We know what to do with ".school" because the call for ".school" was captured as part of the stack iteration. During the iteration of the expression tree in the visitor we were able to capture each portion of the tree.</p>
<p>Look:</p>
<p><img src="http://onoffswitch.net/wp-content/uploads/2014/04/2014-04-03-21_14_26-.png" alt="2014-04-03 21_14_26-" width="370" height="133" class="aligncenter size-full wp-image-4500" /></p>
<p>Given that we have each piece we can now inspect it and manipulate other pieces with it</p>
<p><img src="http://onoffswitch.net/wp-content/uploads/2014/04/2014-04-03-20_58_12-NoNulls-Debugging-Microsoft-Visual-Studio-Administrator.png" alt="2014-04-03 20_58_12-NoNulls (Debugging) - Microsoft Visual Studio (Administrator)" width="725" height="187" class="aligncenter size-full wp-image-4495" /></p>
<p>Now lets assign it to a variable</p>
<p><img src="http://onoffswitch.net/wp-content/uploads/2014/04/2014-04-03-20_59_07-NoNulls-Debugging-Microsoft-Visual-Studio-Administrator.png" alt="2014-04-03 20_59_07-NoNulls (Debugging) - Microsoft Visual Studio (Administrator)" width="551" height="69" class="aligncenter size-full wp-image-4496" /></p>
<p>From here on out we've cached the value.</p>
<p>The evaluate expression function is pretty simple:</p>
<p>[csharp]<br />
private Expression EvaluateExpression(Expression current, Expression prev)<br />
{<br />
    if (prev == null)<br />
    {<br />
        return current;<br />
    }</p>
<p>    if (current is MethodCallExpression)<br />
    {<br />
        var method = current as MethodCallExpression;</p>
<p>        return Expression.Call(prev, method.Method, method.Arguments);<br />
    }</p>
<p>    if (current is MemberExpression)<br />
    {<br />
        var member = current as MemberExpression;</p>
<p>        return Expression.MakeMemberAccess(prev, member.Member);<br />
    }</p>
<p>    return current;<br />
}<br />
[/csharp]</p>
<p>The rest of the work is boilerplate of creating if checks and returning the final result when necessary</p>
<p>[csharp]<br />
private Expression OnNull(ConstantExpression stringRepresentation)<br />
{<br />
    var falseVal = Expression.Constant(false);</p>
<p>    var nullValue = Expression.Constant(default(T), _finalExpression.Type);</p>
<p>    return Expression.New(MethodValueConstructor, new Expression[] { nullValue, stringRepresentation, falseVal });<br />
}</p>
<p>private Expression CheckForNull(ParameterExpression variable, Expression whenNull, Expression nextExpression)<br />
{<br />
    var ifNull = Expression.ReferenceEqual(variable, Expression.Constant(null));</p>
<p>    return Expression.Condition(ifNull, whenNull, nextExpression);<br />
}</p>
<p>private Expression LastExpression(ParameterExpression variable, ConstantExpression stringRepresentation)<br />
{<br />
    var trueVal = Expression.Constant(true);</p>
<p>    return Expression.New(MethodValueConstructor, new Expression[] { variable, stringRepresentation, trueVal });<br />
}<br />
[/csharp]</p>
<h2>Conclusion</h2>
<p>Building expression tree's was a little complicated. There aren't any return statements, and I ran into a lot of weird errors assigning and accessing variables (you need to use certain overloads of the block expression, which I only figured out after reading a <a href="http://stackoverflow.com/a/3370894/310196" target="_blank" rel="noopener noreferrer">jon skeet answer</a> on stack overflow). Still, the resulting code is concise and clean, and until the .? operator shows up this isn't a bad alternative!  </p>
<p>Full source is available at my <a href="https://github.com/devshorts/MonadicNull" target="_blank" rel="noopener noreferrer">github</a></p>
