---
layout: post
title: RESTful web endpoints on Netduino Plus
date: 2012-12-05 16:04:59.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
- Imported
tags:
- c#
- netduino
meta:
  _syntaxhighlighter_encoded: '1'
  _edit_last: '1'
  dsq_thread_id: '960058829'
  _oembed_6644b5b4a8d30fa08744bc9c40b01817: "{{unknown}}"
  _su_title: ''
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1561690990;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:4939;}i:1;a:1:{s:2:"id";i:3392;}i:2;a:1:{s:2:"id";i:4919;}}}}
  _oembed_05817a7a6a9145d7919112c8afdc35ce: "{{unknown}}"
  _oembed_44de245a5cb4857f2c9dd76d6025a72f: "{{unknown}}"
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2012/12/05/rest-endpoints-with-netduino-web-server/"
---
<p><em>This article was originally published at <a href="http://tech.blinemedical.com/rest-endpoints-with-netduino-web-server/" target="_blank" rel="noopener noreferrer">tech.blinemedical.com</a></em></p>
<p>I have a <a href="http://www.Netduino.com/Netduinoplus/specs.htm" target="_blank" rel="noopener noreferrer">Netduino plus</a> at home and I love it. Not only can you use C# to write for it, but you get full visual studio integration including live breakpoints! I got the Netduino plus over the Netduino because the Netduino plus has a built in ethernet jack and ethernet stack support. This way I could access my microcontroller over the web if I wanted to (and who wouldn't?).</p>
<p>But to expose your Netduino to the web you need to write a simple web server. Basically open a socket at port 80 and read/write requests out to it. The Netduino community is great at sharing code and I quickly found a nice web server by <a href="http://www.schuurmans.cc/multi-threaded-web-server-for-Netduino-plus" target="_blank" rel="noopener noreferrer">Jasper Schuurmans</a>. His server code let you define <a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener noreferrer">RESTful</a> routes like this</p>
<p>[csharp]<br />
http://NetduinoIPAddress/targetFunction/arg1/arg2/...<br />
[/csharp]</p>
<p>Which was super cool. It even filtered out non-registered commands, allowing you to control what requests would trigger a "<em>command found</em>" event. Here is the basic main of his demo.</p>
<p>[csharp]<br />
public static void Main()<br />
{<br />
    // Instantiate a new web server on port 80.<br />
    WebServer server = new WebServer(80);</p>
<p>    // Add a handler for commands that are received by the server.<br />
    server.CommandReceived += new WebServer.CommandReceivedHandler(server_CommandReceived);</p>
<p>    // Add a command that the server will parse.<br />
    // Any command name is allowed; you will decide what the command does<br />
    // in the CommandReceived handler. The server will only fire CommandReceived<br />
    // for commands that are defined here and that are called with the proper<br />
    // number of arguments.<br />
    // In this example, I define a command 'SetLed', which needs one argument (on/off).<br />
    // With this statement, I defined that we can call our server on (for example)<br />
    // http://[server-ip]/SetLed/on<br />
    // http://[server-ip]/SetLed/off<br />
    server.AllowedCommands.Add(new WebCommand(&quot;SetLed&quot;, 1));</p>
<p>    // Start the server.<br />
    server.Start();</p>
<p>    // Make sure Netduino keeps running.<br />
    while (true)<br />
    {<br />
        Debug.Print(&quot;Netduino still running...&quot;);<br />
        Thread.Sleep(10000);<br />
    }<br />
}</p>
<p>/// &lt;summary&gt;<br />
/// Handles the CommandReceived event.<br />
/// &lt;/summary&gt;<br />
private static void server_CommandReceived(object source, WebCommandEventArgs e)<br />
{</p>
<p>    Debug.Print(&quot;Command received:&quot; + e.Command.CommandString);</p>
<p>    switch (e.Command.CommandString)<br />
    {<br />
        case &quot;SetLed&quot;:<br />
            {<br />
                // Do you stuff with the command here. Set a led state, return a<br />
                // sampled value of an analog input, whatever.<br />
                // Use the ReturnString property to (optionally) return something<br />
                // to the web user.</p>
<p>                // Read led state from command and set led state.<br />
                bool state = ( e.Command.Arguments[0].Equals(&quot;on&quot;) ? true : false);<br />
                onBoardLed.Write(state);</p>
<p>                // Return feedback to web user.<br />
                e.ReturnString = &quot;&lt;html&gt;&lt;body&gt;You called SetLed with argument: &quot; + e.Command.Arguments[0].ToString() + &quot;&lt;/body&gt;&lt;/hmtl&gt;&quot;;<br />
                break;<br />
            }<br />
    }<br />
}<br />
[/csharp]</p>
<p>While this certainly works, there were a few things I didn't like about this setup:</p>
<ul>
<li>You have to route the logic from a single switch statement. If you were building more than one restful endpoint in your Netduino, this centralized switch statement would get messy.</li>
<li>You have to declare the target argument length when registering the command. This means that if you update the target function's argument parameters, you also have to update the registration code.</li>
<li>The server was single-threaded. It uses events to alter program flow. But since events execute in the dispatchers thread, if your execution code took a while, you basically stalled the entire server.</li>
<li>REST endpoints were actually case sensitive</li>
</ul>
<h1>The reworked final copy</h1>
<p>Before we dig into what I changed, lets look at my final reworked main and you can compare it to the original main I posted above:</p>
<p>[csharp]<br />
public static void Main()<br />
{<br />
    LcdWriter.Instance.Write(&quot;Web Demo Ready!&quot; + DateTime.Now.TimeOfDay);</p>
<p>    WebServerWrapper.InitializeWebEndPoints(new ArrayList<br />
                                                {<br />
                                                    new BasicPage()<br />
                                                });</p>
<p>    WebServerWrapper.StartWebServer();</p>
<p>    RunUtil.KeepRunning();<br />
}<br />
[/csharp]</p>
<p>Here, <code>BasicPage</code> is an object that encapsulates its route definitions as well as what to invoke when a target route is found.  Next, I'm registering the object with a web service wrapper and then starting the web server.  This way, I've removed the command handling from our main loop and encapsulated logic into individual components.</p>
<h1>Injecting endpoints</h1>
<p>In order to get rid of the central switch statement, I wanted to encapsulate all the logic of endpoint name, endpoint arguments, and target function to invoke in a single object. This would let me build a single class whose sole job was to be executed when the web server routed it the command. On top of that, you now can cleanly maintain endpoint state and other information all within a single object. So, if you were building an endpoint whose job is to show you the temperature of your refrigerator over the last 3 hours, you can store that information in your endpoint object and when the endpoint is invoked, print out some nice html that shows the current and historical data.</p>
<p>As an example, let's create a class that prints whatever arguments were received from the server onto a connected LCD. First we'll have it implement a target interface called <code>IEndPointProvider</code> which looks like this:</p>
<p>[csharp]<br />
public interface IEndPointProvider<br />
{<br />
    void Initialize();<br />
    ArrayList AvailableEndPoints();<br />
}<br />
[/csharp]</p>
<ul>
<li><code>Initialize</code> would be class specific initialization logic. If we don't need to use resources until we are about to fire up the server then we can put that logic into here.</li>
<li><code>AvailableEndPoints</code> is a list of <code>EndPoints</code> that we can use to register with the server. In case you're wondering about the <code>ArrayList</code>, .NET Micro <a href="http://informatix.miloush.net/Microframework/Articles/CisFeatures.aspx" target="_blank" rel="noopener noreferrer">doesn't support generics</a>, so we're not using something like <code>List&lt;T&gt;</code></li>
</ul>
<p>And here is my implementation of <code>IEndPointProvider</code> which echos the arguments to a connected LCD:</p>
<p>[csharp]<br />
public class BasicPage : IEndPointProvider<br />
{<br />
    #region Endpoint initialization</p>
<p>    public void Initialize() { }</p>
<p>    public ArrayList AvailableEndPoints()<br />
    {<br />
        var list = new ArrayList<br />
            {<br />
                new EndPoint<br />
                    {<br />
                        Action = Echo,<br />
                        Name = &quot;echoArgs&quot;,<br />
                        Description = &quot;Writes the URL arguments to a serial LCD hooked up to COM1&quot;<br />
                    }<br />
            };<br />
        return list;<br />
    }</p>
<p>    #endregion</p>
<p>    #region Endpoint Execution</p>
<p>    private string Echo(EndPointActionArguments misc, string[] items)<br />
    {<br />
        String text = &quot;&quot;;<br />
        if (items != null &amp;&amp; items.Length &gt; 0)<br />
        {<br />
            foreach (var item in items)<br />
            {<br />
                text += item + &quot; &quot;;<br />
            }<br />
        }<br />
        else<br />
        {<br />
            text = &quot;No arguments!&quot;;<br />
        }</p>
<p>        LcdWriter.Instance.Write(text);</p>
<p>        return &quot;OK. Wrote out: &quot; + (text.Length == 0 ? &quot;n/a&quot; : text);<br />
    }</p>
<p>    #endregion<br />
}<br />
[/csharp]</p>
<p>You can see that we're exposing an array list of <code>EndPoint</code> objects that define the action to execute, what the target action's name is (i.e. the REST endpoint), and a short description about what the endpoint does (for an API listing we can create later).  </p>
<p>The target function <code>Echo</code> takes an <code>EndPointActionArguments</code> object that contains some state about the current connection, and a list of objects representing the variable arguments to the REST endpoint.</p>
<h1>End point</h1>
<p>Let's take a look at what an endpoint is. </p>
<p>[csharp]<br />
public delegate string EndPointAction(EndPointActionArguments arguments, params string[] items);</p>
<p>public class EndPointActionArguments<br />
{<br />
    public Socket Connection { get; set; }<br />
}</p>
<p>public class EndPoint<br />
{<br />
    private string[] _arguments;</p>
<p>    public bool UsesManualSocket { get; set; }</p>
<p>    public string Description { get; set; }</p>
<p>    /// &lt;summary&gt;<br />
    /// The function to be called when the endpoint is hit<br />
    /// &lt;/summary&gt;<br />
    public EndPointAction Action<br />
    {<br />
        private get; set;<br />
    }</p>
<p>    /// &lt;summary&gt;<br />
    /// The name of the endpoint, this is basically the servers route<br />
    /// &lt;/summary&gt;<br />
    public String Name { get; set; }</p>
<p>    public string[] Arguments { set { _arguments = value; } }</p>
<p>    /// &lt;summary&gt;<br />
    /// Execute this endpoint. We'll call the action with the supplied arguments and<br />
    /// return whatever string the action returns.<br />
    /// &lt;/summary&gt;<br />
    /// &lt;returns&gt;&lt;/returns&gt;<br />
    public String Execute(EndPointActionArguments misc)<br />
    {<br />
        if (Action != null)<br />
        {<br />
            return Action(misc, _arguments);<br />
        }<br />
        return &quot;Unknown action&quot;;<br />
    }<br />
}<br />
[/csharp]</p>
<p>An <code>EndPoint</code> has a delegate named <code>Action</code> for a function with a signature</p>
<p>[csharp]<br />
string Foo(EndPointActionArguments arguments, params string[] items)<br />
[/csharp]</p>
<p>The <code>Action</code> would return a string that the web server will then write back out onto the target socket. We also pass an <code>EndPointActionArguments</code> to the delegate which contains a reference to the original socket request (outgoing to the client) and serves as encapsulation if we want to add more parameters to send through to the endpoint later. The last argument is a variable list of strings that relates to the REST url argument list.</p>
<p>An endpoint <code>Description</code> defines what the endpoint does; we'll use this to describe the endpoint in a default API listing if the server gets a request it doesn't know about.</p>
<p><code>UseManualSocket</code> is a boolean that will indicate to the server that the endpoint handled the socket request manually (i.e. it held onto the request) and that the server shouldn't close the socket; the endpoint will deal with socket cleanup.</p>
<h1>Getting the endpoint to the server</h1>
<p>Now that I've encapsulated action/state information into a single class, I wrapped Jasper's original web server with a new facade. The facade will hide some of the internals of the server such as starting the web server, registering endpoints (from <code>IEndPointProvider</code> instances), and provides a single entry point for found commands. When we start the server we'll pass along our registered endpoints with the actual server. If we wanted to do more endpoint manipulation later, we now have a centralized point of access before the endpoints get to the server.</p>
<p>Keeping with the original event dispatching mechanism, I moved the handling of the <code>EndPointReceived</code> event into the wrapper and out of the main program.</p>
<p>[csharp]<br />
/// &lt;summary&gt;<br />
/// Wrapper class on top of a multi threaded web server<br />
/// Allows classes to register REST style endpoints<br />
/// &lt;/summary&gt;<br />
public static class WebServerWrapper<br />
{<br />
    private static WebServer _server;<br />
    private static ArrayList _endPoints;</p>
<p>    /// &lt;summary&gt;<br />
    /// Register REST endpoint for callback invocation with the web server<br />
    /// &lt;/summary&gt;<br />
    /// &lt;param name=&quot;endPoints&quot;&gt;&lt;/param&gt;<br />
    private static void RegisterEndPoints(ArrayList endPoints)<br />
    {<br />
        if(_endPoints == null)<br />
        {<br />
            _endPoints = new ArrayList();<br />
        }</p>
<p>        foreach(var endPoint in endPoints)<br />
        {<br />
            _endPoints.Add(endPoint);<br />
        }<br />
    }</p>
<p>    public static void InitializeWebEndPoints(ArrayList items)<br />
    {<br />
        foreach (IEndPointProvider endpoint in items)<br />
        {<br />
            endpoint.Initialize();<br />
            RegisterEndPoints(endpoint.AvailableEndPoints());<br />
        }<br />
    }</p>
<p>    /// &lt;summary&gt;<br />
    /// Start listening on the port and enable any registered callbacks<br />
    /// &lt;/summary&gt;<br />
    /// &lt;param name=&quot;port&quot;&gt;&lt;/param&gt;<br />
    /// &lt;param name=&quot;enabledLedStatus&quot;&gt;&lt;/param&gt;<br />
    public static void StartWebServer(int port = 80, bool enabledLedStatus = true)<br />
    {<br />
        _server = new WebServer(port, enabledLedStatus);</p>
<p>        _server.EndPointReceived += EndPointHandler;</p>
<p>        foreach (EndPoint endpoint in _endPoints)<br />
        {<br />
            _server.RegisterEndPoint(endpoint);<br />
        }</p>
<p>        // Initialize the server.<br />
        _server.Start();<br />
    }</p>
<p>    /// &lt;summary&gt;<br />
    /// We'll get an endpoint invocation from the web server<br />
    /// so we can execute the endpoint action and response based on its supplied arguments<br />
    /// in a separate thread, hence the event. we'll set the event return string<br />
    /// so the web server can know how to respond back to the ui in a seperate thread<br />
    /// &lt;/summary&gt;<br />
    /// &lt;param name=&quot;source&quot;&gt;&lt;/param&gt;<br />
    /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;<br />
    private static void EndPointHandler(object source, EndPoinEventArgs e)<br />
    {<br />
        var misc = new EndPointActionArguments<br />
                        {<br />
                            Connection = e.Connection<br />
                        };</p>
<p>        e.ReturnString = e.Command.Execute(misc);</p>
<p>        // we can override the manual use of the socket if we returned a value other than null<br />
        if (e.ReturnString != null &amp;&amp; e.Command.UsesManualSocket)<br />
        {<br />
            e.ManualSent = false;<br />
        }<br />
        else<br />
        {<br />
            e.ManualSent = e.Command.UsesManualSocket;<br />
        }<br />
    }<br />
}<br />
[/csharp]</p>
<h1>A few web server changes</h1>
<p>Jaspers web server is simple and ingenious. I like it's simplicity and it was easy to extend. When the web server receives a request, it parses the first line of a raw http GET from the header to figure out it's "route". As an example, here is a request I generated for <em>http://localhost/function/arg1/arg2</em>. Everything after the first line is discarded since we just care about the <em>/function/arg1/arg2</em> part</p>
<p>[csharp]<br />
GET /function/arg1/arg2 HTTP/1.1<br />
Host: localhost<br />
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11<br />
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br />
Accept-Encoding: gzip,deflate,sdch<br />
Accept-Language: en-US,en;q=0.8<br />
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3<br />
Cookie: ASP.NET_SessionId=ue1s3blzxxwbrrohasgwpbbv<br />
[/csharp]</p>
<p>Once it has the right request url from the header, the server will see if any registered endpoint <code>Name</code> property matches the request name. If it does it'll parse the remaining arguments. This all happens in <code>InterpretRequest</code>. I didn't change any of this logic. What I changed was what <code>InterpretRequest</code> returns and how the final command is dispatched. Here is the main server listening loop:</p>
<p>[csharp]<br />
using (var server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))<br />
{<br />
    server.Bind(new IPEndPoint(IPAddress.Any, Port));</p>
<p>    server.Listen(1);</p>
<p>    while (!_cancel)<br />
    {<br />
        var connection = server.Accept();</p>
<p>        if (connection.Poll(-1, SelectMode.SelectRead))<br />
        {<br />
            // Create buffer and receive raw bytes.<br />
            var bytes = new byte[connection.Available];</p>
<p>            connection.Receive(bytes);</p>
<p>            // Convert to string, will include HTTP headers.<br />
            var rawData = new string(Encoding.UTF8.GetChars(bytes));</p>
<p>            //====================================<br />
            // My changes begin here<br />
            //====================================<br />
            EndPoint endPoint = InterpretRequest(rawData);</p>
<p>            if (endPoint != null)<br />
            {<br />
                if (_enableLedStatus)<br />
                {<br />
                    PingLed();<br />
                }</p>
<p>                // dispatch the endpoint<br />
                var e = new EndPoinEventArgs(endPoint, connection);</p>
<p>                if (EndPointReceived != null)<br />
                {<br />
                    ThreadUtil.SafeQueueWorkItem(() =&gt;<br />
                        {<br />
                            EndPointReceived(null, e);</p>
<p>                            if (e.ManualSent)<br />
                            {<br />
                                // the client should close the socket<br />
                            }<br />
                            else<br />
                            {<br />
                                var response = e.ReturnString;</p>
<p>                                SendResponse(response, connection);<br />
                            }<br />
                        });<br />
                }<br />
            }<br />
            else<br />
            {<br />
                // if we didn't match a response return with the generic API listing<br />
                SendResponse(GetApiList(), connection);<br />
            }<br />
        }</p>
<p>    }<br />
}<br />
[/csharp]</p>
<p>What I modified from the original server code was</p>
<ul>
<li>InterpretRequest now returns an <code>EndPoint</code> with a string array of arguments. Previously, it looked for only the number of arguments that were registered to it. Now it parses as much as is there giving you a clean variable argument list.</li>
<li>Events are now dispatched in a <a href="https://github.com/blinemedical/NWebREST/blob/master/NetDuinoUtils/Utils/ThreadUtil.cs" target="_blank" rel="noopener noreferrer">custom threadpool</a>, since <a href="http://netmf.codeplex.com/workitem/78" target="_blank" rel="noopener noreferrer">.NET Micro doesn't have any</a> built in threadpooling. The threadpool is a collection of 3 threads that pull off an event queue and execute. This way the web server is asynchronous and won't ever block for other requests. You could easily just have it fire off independent threads if you wanted to, but I found a threadpool to be more effective since you don't need to spin up new threads (and allocate extra thread stack space) each time.</li>
<li>If a request comes in that doesn't match any endpoint, we'll print out all the available endpoints with their description. This is a nice API listing for you.</li>
<li>Event arguments contain a reference to the original socket if you need it.</li>
<li>If an endpoint is going to to manually write to the socket and close the socket later, it can set the <code>UsesManualSocket</code> flag on registration. The wrapper then tells the server that the executed endpoint manually sent data to the socket and is expected to close it. This can be useful if you want to maintain a persistent connection in your endpoint (maybe you are streaming something per client). By default the server will write out the string response from the endpoint and close the socket.</li>
<li>Optionally pulse the onboard LED whenever a request comes in. This is useful for debugging and viewing activity.</li>
<li>I updated the code that searched for endpoint name and compared it to url request to be case insensitive. Even though the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2.3" target="_blank" rel="noopener noreferrer">w3c spec</a> says comparing  urls should be case sensitive (with some exceptions), <a href="http://stackoverflow.com/questions/778203/are-there-any-naming-convention-guidelines-for-rest-apis" target="_blank" rel="noopener noreferrer">by convention</a> REST endpoints are case insensitive</li>
</ul>
<h1>Review</h1>
<p>Lets take a look again at our main program block.</p>
<p>[csharp]<br />
public static void Main()<br />
{<br />
    LcdWriter.Instance.Write(&quot;Web Demo Ready!&quot; + DateTime.Now.TimeOfDay);</p>
<p>    WebServerWrapper.InitializeWebEndPoints(new ArrayList<br />
                                                {<br />
                                                    new BasicPage()<br />
                                                });</p>
<p>    WebServerWrapper.StartWebServer();</p>
<p>    RunUtil.KeepRunning();<br />
}<br />
[/csharp]</p>
<p>You can see that we've now decoupled public interaction with the web server, as well as allow each class to define whatever routes it wants. If we wanted to rename the route <code>EchoArgs</code> and have it point to another function, it'd be trivial to change that within <code>BasicPage</code>. If we wanted <code>BasicPage</code> to implement two functions such as <code>EchoArgs</code> and <code>BlinkLEDABunch</code> we could do that, all without having to update our main entrypoint.</p>
<p>Just to recap, the basic pattern here is:</p>
<p><a href="http://tech.blinemedical.com/wp-content/uploads/2012/11/flow.png"><img class="aligncenter size-medium wp-image-1731" src="http://tech.blinemedical.com/wp-content/uploads/2012/11/flow-300x179.png" alt="Program Flow Diagram" width="300" height="179" /></a></p>
<ul>
<li>First register all <code>IEndPointProvider</code>s with the web server wrapper.</li>
<li>Then start web server.</li>
<li>When a request comes in, the server will find a matching endpoint by name and dispatch the <code>EndPointReceived</code> event which is caught by the wrapper.</li>
<li>The wrapper executes the target endpoint in a separate thread and returns the endpoints result.</li>
</ul>
<p>From a users perspective, you just create your class, expose your endpoint, and everything works.</p>
<h1>Demo</h1>
<p>Firing up the app</p>
<p><a href="http://tech.blinemedical.com/wp-content/uploads/2012/11/netduinoOutput1-e1353965312698.jpg"><img class="aligncenter size-medium wp-image-1604" src="http://tech.blinemedical.com/wp-content/uploads/2012/11/netduinoOutput1-e1353965295230-300x225.jpg" alt="Netduion output: starting app" width="300" height="225" /></a></p>
<p>Using curl to send some arguments</p>
<p>[csharp]<br />
&gt;curl http://192.168.2.11/echoargs/heyguys!/whatsup!<br />
OK. Wrote out: heyguys! whatsup!<br />
[/csharp]</p>
<p>Results on the Netduino</p>
<p><a href="http://tech.blinemedical.com/wp-content/uploads/2012/11/netduinoOutput2-e1353965375217.jpg"><img class="aligncenter size-medium wp-image-1605" src="http://tech.blinemedical.com/wp-content/uploads/2012/11/netduinoOutput2-e1353965375217-300x225.jpg" alt="Netduion output: endpoint executed" width="300" height="225" /></a></p>
<p>The API listing (this prints when no known route was found)</p>
<p><a href="http://tech.blinemedical.com/wp-content/uploads/2012/11/apiList..png"><img class="aligncenter size-medium wp-image-1617" src="http://tech.blinemedical.com/wp-content/uploads/2012/11/apiList.-300x255.png" alt="The API listing" width="300" height="255" /></a></p>
<h1>The source</h1>
<p>Full source and demo code available at our <a href="https://github.com/blinemedical/NWebREST" target="_blank" rel="noopener noreferrer">github</a>. Note, the project is built against .net micro 4.2. I've run the code on .net micro 4.1 and 4.2 and everything worked fine. For reference, currently my Netduino is on firmware 4.2.0.0. RC3, though I'm not relying on any major framework specific choices here so it should continue to work fine for later revisions.</p>
