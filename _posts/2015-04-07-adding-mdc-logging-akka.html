---
layout: post
title: Adding MDC logging to akka
date: 2015-04-07 01:05:20.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- akka
- java
- MDC
- slf4j
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  _wpas_done_all: '1'
  _su_rich_snippet_type: none
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1560404400;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:4596;}i:1;a:1:{s:2:"id";i:4629;}i:2;a:1:{s:2:"id";i:4593;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2015/04/07/adding-mdc-logging-akka/"
---
<p>I've mentioned before, but I'm working heavily in a project that is leveraging akka. I am really enjoying the message passing model and so far things are great, but tying in an MDC for the SLFJ logging context proved complicated.  I had played with the custom executor model described <a href="http://yanns.github.io/blog/2014/05/04/slf4j-mapped-diagnostic-context-mdc-with-play-framework/">here</a> but hadn't attempted the akka custom dispatcher.</p>
<p>I was thinking that a custom dispatcher would work great to pass along the MDC since then you'd never have to think about it, but unfortunately I couldn't get it to work. Akka kept failing to instantiate the dispatcher. I was also worried about configuration data and possible tuning that you might lose giving akka your own dispatcher configurator. </p>
<p>So, given that I wasn't quite sure what to do. What I ended up with however was a little extra work but turned out well.  I went with an augmented dispatcher/subscriber model. Basically for every event that I send out I wrap it in a <code>PersistentableMessage</code> which traps the fields of the MDC that I care about, and then on any actor I have them subclass a custom logging base class that pops out the persistent message container, sets the MDC, and gives the actor the underlying message.</p>
<p>For my project we're tracking everything with what we call a <code>CorrelationId</code> which is just a UUID.</p>
<h2>The message wrapper</h2>
<p>[java]<br />
@Data<br />
public class PersistableMessageContext implements CorrelationIdGetter, CorrelationIdSetter {<br />
    private final Object source;</p>
<p>    private UUID correlationId;</p>
<p>    public PersistableMessageContext(Object source){<br />
        this.source = source;</p>
<p>        try {<br />
            final String s = MDC.get(FilterAttributes.CORR_ID);</p>
<p>            setCorrelationId(UUID.fromString(s));<br />
        }<br />
        catch(Throwable ex){}<br />
}<br />
[/java]</p>
<p>This is the message that I want to pass around.  By containing its source correlation ID it can later be used to set the context when its being consumed</p>
<h2>The actor base</h2>
<p>I now have all my actors subclass this class</p>
<p>[java]<br />
public abstract class LoggableActor extends UntypedActor {<br />
    @Override public void onReceive(final Object message) throws Exception {<br />
        Boolean wasSet = false;</p>
<p>        if (CorrelationIdGetter.class.isAssignableFrom(message.getClass())) {<br />
            final UUID correlationId = ((CorrelationIdGetter) message).getCorrelationId();</p>
<p>            if (correlationId != null) {<br />
                MDC.put(FilterAttributes.CORR_ID, correlationId.toString());</p>
<p>                wasSet = true;<br />
            }<br />
        }</p>
<p>        if (message instanceof PersistableMessageContext) {<br />
            onReceiveImpl(((PersistableMessageContext) message).getSource());<br />
        }<br />
        else {<br />
            onReceiveImpl(message);<br />
        }</p>
<p>        if(wasSet) {<br />
            MDC.remove(FilterAttributes.CORR_ID);<br />
        }<br />
    }</p>
<p>    public abstract void onReceiveImpl(final Object message) throws Exception;<br />
}<br />
[/java]</p>
<p>This lets me pass in anything that implements a <code>CorrelationIdGetter</code> and if it happens to also be a persisted message, pop out the inner message.</p>
<h2>Sending out messages</h2>
<p>Now the big issue here is to make sure that we are consistent in publishing messages. This means using routers, broadcasts, etc, all  have to make sure to push out a message wrapped in a persistent container. To help make that easier I created a few augmented akka publisher classes. Below is a class with static methods (to make it easy to import) that wrap an actor ref or a router.</p>
<p>[java]<br />
import akka.actor.ActorRef;<br />
import akka.routing.Broadcast;<br />
import akka.routing.Router;</p>
<p>/**<br />
 * Utilitiy to provide context propagation on akka messages<br />
 */<br />
public class AkkaAugmenter {</p>
<p>    public static AkkaAugmentedActor wrap(ActorRef src) {<br />
        return new AkkaAugmentedActor(){<br />
            @Override public void tell(final Object msg, final ActorRef sender) {<br />
                final PersistableMessageContext persistableMessageContext = new PersistableMessageContext(msg);</p>
<p>                src.tell(persistableMessageContext, sender);<br />
            }</p>
<p>            @Override public ActorRef getActor() {<br />
                return src;<br />
            }<br />
        };<br />
    }</p>
<p>    public static AkkaAugmentedRouter wrap(Router src) {<br />
       return new AkkaAugmentedRouter() {<br />
           @Override public void route(final Object msg, final ActorRef sender) {<br />
               final PersistableMessageContext persistableMessageContext = new PersistableMessageContext(msg);</p>
<p>               src.route(persistableMessageContext, sender);<br />
           }</p>
<p>           @Override public void broadcast(final Object msg, final ActorRef sender) {<br />
               final PersistableMessageContext persistableMessageContext = new PersistableMessageContext(msg);</p>
<p>               src.route(new Broadcast(persistableMessageContext), sender);<br />
           }</p>
<p>           @Override public Router getRouter() {<br />
               return src;<br />
           }<br />
       };<br />
    }<br />
}<br />
[/java]</p>
<p>The augmented actor:</p>
<p>[java]<br />
public interface AkkaAugmentedActor {<br />
    void tell(Object msg, ActorRef sender);</p>
<p>    ActorRef getActor();<br />
}<br />
[/java]</p>
<p>And the augmented router:</p>
<p>[java]<br />
public interface AkkaAugmentedRouter {<br />
    void route(Object msg, ActorRef sender);</p>
<p>    void broadcast(Object msg, ActorRef sender);</p>
<p>    Router getRouter();<br />
}<br />
[/java]</p>
<h2>Conclusion</h2>
<p>And now all I need to do is to wrap a default actor or router give to me by akka. From here on out all messages are auto wrapped and my MDC is properly propagated.  While I would have liked to not rely on convention this way, at least I made it simple once you've made the right types.  </p>
