---
layout: post
title: Single producer many consumer
date: 2014-02-26 22:21:12.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- async
- queue
- Rx
- topic
meta:
  _su_rich_snippet_type: none
  _wpas_done_all: '1'
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1561845469;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:532;}i:1;a:1:{s:2:"id";i:2985;}i:2;a:1:{s:2:"id";i:7777;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2014/02/26/single-producer-consumer/"
---
<p>When I'm bored, I like to roll my own versions of things that already exist. That's not to say I use them in production, but I find that they are great learning tools. If you read the blog regularly you probably have realized I do this A LOT.  Anyways, today is no different. I was thinking about single producer, multiple consumer functions, like an <a href="http://aws.amazon.com/sns/" target="_blank" rel="noopener noreferrer">SNS</a> Topic, but for your local machine.  In reality, the best way to do this would be to publish your event through an Rx stream and consume it with multiple subscribers, but that's no fun. I want to roll my own!</p>
<p>BlockingCollection in .NET supports thread safe multiple consumers, but only 1 item will ever get dequeued from your collection. That means that if you have multiple threads waiting on a consuming enumerable, only one of them will get a result (not all of them). That's not that good if you want to have copies of your item dispatched to multiple subscribers.  But, if that is what you want, check out this other <a href="http://onoffswitch.net/async-producerconsumer-the-easy-way/" target="_blank" rel="noopener noreferrer">post of mine</a>.</p>
<p>What I need is a blocking consumer, a way to publish items, a threadsafe way to add and remove subscriptions, and a way to concurrently dispatch dequeued items to subscribed consumers. </p>
<p>First let me show a subscriber instance. This is like a public token that the consumer of the topic will get when they subscribe.  All it has is a registered <code>OnNext</code> action and a way to unsubscribe itself from whatever its subscribed to. </p>
<p>[csharp]<br />
public class Subscriber&lt;T&gt;{<br />
	private Action&lt;Subscriber&lt;T&gt;&gt; UnSubscribeAction { get; set; }</p>
<p>	public Action&lt;T&gt; OnNext{ get; private set; }</p>
<p>	public void UnSubscribe(){<br />
		UnSubscribeAction (this);<br />
	}</p>
<p>	public Subscriber(Action&lt;Subscriber&lt;T&gt;&gt; unsubscribe, Action&lt;T&gt; onNext){<br />
		UnSubscribeAction = unsubscribe;</p>
<p>		OnNext = onNext;<br />
	}<br />
}<br />
[/csharp]</p>
<p>And now the actual single producer many consumer (SPMC) implementation.  It's responsible for handling the listening on the consuming enumerable, the dispatching into the blocking collection, as well as parallelizing the re-distribution of the consumers. It's pretty simple!</p>
<p>[csharp]<br />
public class SPMC&lt;T&gt; : IDisposable<br />
{<br />
	public SPMC (int boundedSize = int.MaxValue)<br />
	{<br />
		_blockingCollection = new BlockingCollection&lt;T&gt; (boundedSize);<br />
	}</p>
<p>	private Object _lock = new object();</p>
<p>	private List&lt;Subscriber&lt;T&gt;&gt; _consumers = new List&lt;Subscriber&lt;T&gt;&gt;();</p>
<p>	private BlockingCollection&lt;T&gt; _blockingCollection;</p>
<p>	public Subscriber&lt;T&gt; Subscribe(Action&lt;T&gt; onNext){<br />
		lock (_lock) {</p>
<p>			Action&lt;Subscriber&lt;T&gt;&gt; removalAction = instance =&gt; {<br />
				lock (_lock) {<br />
					_consumers.Remove (instance);<br />
				}<br />
			};</p>
<p>			var subscriber = new Subscriber&lt;T&gt; (removalAction, onNext);</p>
<p>			_consumers.Add (subscriber);</p>
<p>			return subscriber;<br />
		}<br />
	}</p>
<p>	public void Start(){<br />
		new Thread (() =&gt; {<br />
			foreach (var item in _blockingCollection.GetConsumingEnumerable()) {<br />
				lock (_lock) {<br />
					Parallel.ForEach (_consumers, consumer =&gt; consumer.OnNext (item));<br />
				}<br />
			}<br />
		}).Start();<br />
	}</p>
<p>	public void Stop(){<br />
		_blockingCollection.CompleteAdding ();<br />
	}</p>
<p>	public void Publish(T item){<br />
		_blockingCollection.Add (item);<br />
	}</p>
<p>	#region IDisposable implementation</p>
<p>	public void Dispose ()<br />
	{<br />
		Stop ();<br />
	}</p>
<p>	#endregion<br />
}<br />
[/csharp]</p>
<p>And of course, a unit test to demonstrate its usage</p>
<p>[csharp]<br />
[Test]<br />
public void TestCase ()<br />
{<br />
	var subscriber1Collect = new List&lt;string&gt; ();<br />
	var subscriber2Collect = new List&lt;string&gt; ();<br />
	var subscriber3Collect = new List&lt;string&gt; ();</p>
<p>	var spmc = new SPMC&lt;String&gt; ();</p>
<p>	var subscriber1 = spmc.Subscribe(subscriber1Collect.Add);</p>
<p>	spmc.Subscribe(subscriber2Collect.Add);</p>
<p>	spmc.Start ();</p>
<p>	var t = new Thread (() =&gt; {<br />
		while (true) {<br />
			Thread.Sleep (TimeSpan.FromMilliseconds (1000));</p>
<p>			spmc.Publish (DateTime.Now.ToString ());<br />
		}<br />
	});</p>
<p>	t.IsBackground = true;</p>
<p>	t.Start ();</p>
<p>	Thread.Sleep (TimeSpan.FromSeconds (5));</p>
<p>	subscriber1.UnSubscribe ();</p>
<p>	spmc.Subscribe(subscriber3Collect.Add);</p>
<p>	Thread.Sleep (TimeSpan.FromSeconds (5));</p>
<p>	Assert.GreaterOrEqual (subscriber3Collect.Count, 4);<br />
	Assert.GreaterOrEqual (subscriber2Collect.Count, 9);<br />
	Assert.GreaterOrEqual (subscriber1Collect.Count, 4);<br />
}<br />
[/csharp]</p>
<p>The asserts are greater than or equal just to give a 1 second wiggle room for the time dispatch variance.  </p>
