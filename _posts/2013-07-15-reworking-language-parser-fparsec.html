---
layout: post
title: Reworking my language parser with fparsec
date: 2013-07-15 08:00:21.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- abstract syntax trees
- F#
- fparsec
- fsharp
- parsing
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  _su_rich_snippet_type: none
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1560221353;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:2735;}i:1;a:1:{s:2:"id";i:3016;}i:2;a:1:{s:2:"id";i:4365;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2013/07/15/reworking-language-parser-fparsec/"
---
<p>Since I was playing with fparsec last week, I decided to redo (or mostly) the parser for my homebrew language that I've previously posted about.  Using fparsec made the parser surprisingly succinct and expressive.  In fact I was able to do most of this in an afternoon, which is impressive considering<a href="http://onoffswitch.net/a-handrolled-language-parser/" target="_blank" rel="noopener noreferrer"> my last C# attempt</a> took 2 weeks to hammer out.</p>
<p>As always, it starts with the data</p>
<p>[fsharp]<br />
type Op =<br />
    | Plus<br />
    | Minus<br />
    | GreaterThan<br />
    | LessThan<br />
    | Mult<br />
    | Divide<br />
    | Carrot</p>
<p>type Ast =<br />
    | Statement of Ast<br />
    | Expression of Ex<br />
    | Function of string option * Argument list option * Ast<br />
    | Scope of Ast list option<br />
    | Class of Ex * Ast<br />
    | Conditional of Ex * Ast * Ast option<br />
    | WhileLoop of Ex * Ast<br />
    | ForLoop of Ast * Ex * Ex * Ast<br />
    | Call of string * Argument list option<br />
    | Assign of Ex * Ex<br />
and Ex =<br />
    | Single of Ast<br />
    | Full of Ex * Op * Ex<br />
    | Float of float<br />
    | Int of int<br />
    | Literal of string<br />
    | Variable of string<br />
and Argument =<br />
    | Element of Ex<br />
[/fsharp]</p>
<h2>Operators</h2>
<p>Parsing operators is trivial</p>
<p>[fsharp]<br />
let plus = pstring &quot;+&quot; &gt;&gt;% Plus</p>
<p>let minus = pstring &quot;-&quot; &gt;&gt;% Minus</p>
<p>let divide = pstring &quot;/&quot; &gt;&gt;% Divide</p>
<p>let mult = pstring &quot;*&quot; &gt;&gt;% Mult</p>
<p>let carrot = pstring &quot;^&quot; &gt;&gt;% Carrot</p>
<p>let gt = pstring &quot;&gt;&quot; &gt;&gt;% GreaterThan</p>
<p>let lt = pstring  &quot;&lt;&quot; &gt;&gt;% LessThan</p>
<p>let op = spaces &gt;&gt;. choice[plus;minus;divide;mult;carrot;gt;lt]<br />
[/fsharp]</p>
<h2>Expressions</h2>
<p>But what was great was parsing expressions. These were complicated because I had to avoid left recursion, and in my C# parser I had a lot of edge conditions and had to deal with special backtracking. It was a nightmare.  With FParsec you can create forward recursive parsers, basically you create a dummy variable that you use as the recursive parser. Later you populate a tied reference to it with what are the available recursive parser implementations.  </p>
<p>[fsharp]<br />
// create a forward reference<br />
// the expr is what we'll use in our parser combinators<br />
// the exprImpl we'll populate with all the recursive options later<br />
let expr, exprImpl = createParserForwardedToRef()</p>
<p>let expression1 = spaces &gt;&gt;? choice[floatNum;intNum;literal;variable] </p>
<p>let between a b p = pstring a &gt;&gt;. p .&gt;&gt; pstring b</p>
<p>let bracketExpression = expr |&gt; between &quot;(&quot; &quot;)&quot;</p>
<p>let lhExpression = choice[expression1; bracketExpression]</p>
<p>let expressionOperation = lhExpression                           &gt;&gt;=? fun operandL -&gt;<br />
                          op                                     &gt;&gt;=? fun operator -&gt;<br />
                          choice[expr;bracketExpression]         &gt;&gt;=? fun operandR -&gt;<br />
                          preturn (operandL, operator, operandR) |&gt;&gt; Full </p>
<p>do exprImpl := spaces &gt;&gt;. choice[attempt expressionOperation;<br />
                                 attempt bracketExpression;<br />
                                 expression1]<br />
[/fsharp]</p>
<p><code>expression1</code> is a type of expression that is just a single element.  <code>expressionOperation</code> is an expression that has an operator inbetween two expressions.  To avoid left recursion, the left hand side of an expression is limited to either expressions of single elements, or expressions encapsulated in parenthesis.  Then the right hand side can be either a parenthesis expression, or a regular expression.   You'll notice that <code>expr</code> isn't actually defined yet when its used here on line 16. It's a placeholder for the recursive parser, which is tied to the mutable reference cell (exprImpl) that I populate after I've defined all the parsers. This lets you define a parser that can actually call itself recursively!  Neat.</p>
<p>The <code>>>=?</code> operator applies the result to the following function, but if it fails, backtracks to the beginning of that parsers state. </p>
<h2>Scope</h2>
<p>I defined a scope as any valid statements between two curly brackets.</p>
<p>[fsharp]<br />
let funcInners, funcInnersImpl = createParserForwardedToRef()</p>
<p>let scope = parse{<br />
    do! spaces<br />
    do! skipStringCI &quot;{&quot;<br />
    do! spaces<br />
    let! text = opt funcInners<br />
    do! spaces<br />
    do! skipStringCI &quot;}&quot;<br />
    do! spaces<br />
    return Scope(text)<br />
}<br />
[/fsharp]</p>
<p>The forward parser here is going to be populated at the very end of my parser, since it will allow for any kind of statement like while loops, for loops, conditionals, assignment, etc.  All the scope parser cares about is that it got stuff between curly brackets.  Using this we can leverage it anywhere else that has curly brackets. Later on in the program I set this up:</p>
<p>[fsharp]<br />
(* things that can be in functions *)</p>
<p>do funcInnersImpl := many1 (spaces &gt;&gt;? choice [scope; func; statement])<br />
[/fsharp]</p>
<p>Which allows scopes, statements (delineated by semicolons), or other functions, to appear inside of a function or scope. So you can see how a scope and function can be recursive (by containing other scopes and functions inside of them).</p>
<p>Anyways, lets parse a function</p>
<p>[fsharp]<br />
let innerArgs = sepEndBy1 (expr |&gt;&gt; Element) (pstring &quot;,&quot;)<br />
let arguments = innerArgs |&gt; between &quot;(&quot; &quot;)&quot;</p>
<p>let func = parse {<br />
    do! skipStringCI &quot;func&quot;<br />
    do! spaces<br />
    let! name = opt (many1Chars (satisfy isAsciiLetter))<br />
    let! arguments = opt arguments<br />
    do! spaces<br />
    do! skipStringCI &quot;-&gt;&quot;<br />
    let! scope = scope<br />
    return Function(name, arguments, scope)<br />
}<br />
[/fsharp]</p>
<h2>Conditionals</h2>
<p>Conditionals were fun, because you can have an if statement, an if/else, or an if/elseif, or an if/elseif/.../else combo.  In my previous C# parser I covered each type independently so I had a lot of extra overlap, but this time I wanted to see if I could create an aggregate parser combinator to handle all these scenarios for me in one.</p>
<p>[fsharp]<br />
let conditionalParser, conditionalParserImpl = createParserForwardedToRef()</p>
<p>let ifBlock = parse{<br />
    do! skipStringCI &quot;if&quot;<br />
    let! condition = expr |&gt; between &quot;(&quot; &quot;)&quot;<br />
    do! spaces<br />
    let! onTrue = scope<br />
    do! spaces</p>
<p>    let elseKeyword = skipStringCI &quot;else&quot; .&gt;&gt; spaces</p>
<p>    let elseParse = parse{<br />
        do! elseKeyword<br />
        let! onFalse = scope<br />
        return (condition, onTrue, Some(onFalse)) |&gt; Conditional<br />
    }</p>
<p>    let elseIfParse = parse{<br />
        do! elseKeyword<br />
        let! onFalse = conditionalParser<br />
        return (condition, onTrue, Some(onFalse)) |&gt; Conditional<br />
    }</p>
<p>    let noElseParse = parse{<br />
        return (condition, onTrue, None) |&gt; Conditional<br />
    }</p>
<p>    let! result = choice[attempt elseIfParse;elseParse;noElseParse]<br />
    return result<br />
}<br />
[/fsharp]</p>
<p>This time, I created a recursive parser that optionally removes an else statement and captures the scope, or removes the else element and calls back into the if parser, or just terminates (so an if with no else).  The final result is a 3 way alternative that the if block can evaluate.  </p>
<h2>Loops</h2>
<p>Here is a while loop</p>
<p>[fsharp]<br />
let whileLoop = (pstring &quot;while&quot; &gt;&gt;. spaces) &gt;&gt;. (expr |&gt; between &quot;(&quot; &quot;)&quot;) &gt;&gt;= fun predicate -&gt;<br />
                scope &gt;&gt;= fun body -&gt;<br />
                preturn (WhileLoop(predicate, body))<br />
[/fsharp]</p>
<p>And here is a for loop</p>
<p>[fsharp]<br />
let assign = parse{<br />
    let! ex = expr<br />
    do! spaces<br />
    do! skipStringCI &quot;=&quot;<br />
    do! spaces<br />
    let! assignEx = expr<br />
    do! spaces<br />
    return (ex, assignEx) |&gt; Assign<br />
}</p>
<p>let forLoop =<br />
    let startCondition = assign .&gt;&gt; pstring &quot;;&quot;<br />
    let predicate = expr .&gt;&gt; pstring &quot;;&quot;<br />
    let endCondition = expr<br />
    let forKeyword = pstring &quot;for&quot; .&gt;&gt; spaces</p>
<p>    let forItems = tuple3 startCondition predicate endCondition |&gt; between &quot;(&quot; &quot;)&quot;</p>
<p>    forKeyword &gt;&gt;. forItems .&gt;&gt;. scope &gt;&gt;= fun ((start, predicate, end), body) -&gt;<br />
        preturn (start, predicate, end, body) |&gt;&gt; ForLoop<br />
[/fsharp]</p>
<p>Which gives you a result like this</p>
<p>[code]<br />
test &quot;for(x=1;y&lt;z;y+1){}&quot;;;<br />
val it : Ast list =<br />
  [ForLoop<br />
     (Assign (Variable &quot;x&quot;,Float 1.0),<br />
      Full (Variable &quot;y&quot;,LessThan,Variable &quot;z&quot;),<br />
      Full (Variable &quot;y&quot;,Plus,Float 1.0),Scope null)]<br />
[/code]</p>
<h2>Conclusion</h2>
<p>My fiance is probably pissed that I spent 4th of july working on parser combinators, but fparsec is just too fun not to.  I really can't wait for an opportunity to use this for some production code, since I'm extremely happy with fparsecs abilities and the experience of working in it.  </p>
<p>For the full parser check out this <a href="http://fssnip.net/iJ" target="_blank" rel="noopener noreferrer">fsharp snippet</a>.</p>
