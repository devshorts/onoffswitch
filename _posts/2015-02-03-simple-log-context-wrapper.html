---
layout: post
title: Simple log context wrapper
date: 2015-02-03 03:09:45.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- logging
- scala
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  _su_rich_snippet_type: none
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"f251743520edff2facd5c40ee081a536";a:2:{s:7:"expires";i:1558534014;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:4593;}i:1;a:1:{s:2:"id";i:4862;}i:2;a:1:{s:2:"id";i:4945;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2015/02/03/simple-log-context-wrapper/"
---
<p>I'm still toying around with the scala play! framework and I wanted to check out how I can make logging contextual information easy.  In the past with .NET I've used and written libraries that wrap the current log provider and give you extra niceties with logging. One of my favorites was being able to do stuff like</p>
<p>[csharp]<br />
var foo = &quot;1&quot;;<br />
var bar = &quot;2&quot;;<br />
logger.With(new { foo, bar }).Info(&quot;data&quot;)<br />
[/csharp]</p>
<p>Which would output a log line like</p>
<p>[code]<br />
data, foo=1; bar=2<br />
[/code]</p>
<p>The logger's "with" was even chainable so you could capture a previously built "with" context and re-use it. It was really nice when you want to create a baseline logging context for complex functions.</p>
<p>Java doesn't have the concept of anonymous classes and I'm not sure you can do optimizations with reflection like you can with .NET (creating reflective based property invokers into delegates).</p>
<p>Either way, this makes for a good experiment.</p>
<p>First off, the final product</p>
<p>[scala]<br />
val logInfo = With(<br />
  &quot;request-uri&quot; -&gt; rh.uri,<br />
  &quot;request-time&quot; -&gt; (System.currentTimeMillis() - start)<br />
)<br />
val compound = logInfo and With(&quot;date&quot; -&gt; &quot;bar&quot;)</p>
<p>logger.info(&quot;handled&quot;, compound)<br />
[/scala]</p>
<p>Which outputs</p>
<p>[code]<br />
[info] LoggingFilter$ - handled request-uri=/; request-time=164; date=bar<br />
[info] LoggingFilter$ - handled request-uri=/assets/javascripts/jquery-1.9.0.min.js; request-time=347; date=bar<br />
[info] LoggingFilter$ - handled request-uri=/assets/stylesheets/main.css; request-time=362; date=bar<br />
[info] LoggingFilter$ - handled request-uri=/assets/images/favicon.png; request-time=478; date=bar<br />
[/code]</p>
<p>This is a snippet I'm playing with in a root level timing filter for a scala play app. The "date -> bar" association is just for demonstration of combining contexts</p>
<p>The full filter looks like</p>
<p>[scala]<br />
object LoggingFilter extends Filter{<br />
  val logger = Log(getClass)</p>
<p>  val start = System.currentTimeMillis()</p>
<p>  override def apply(f: (RequestHeader) =&gt; Future[Result])(rh: RequestHeader): Future[Result] = {</p>
<p>    val result = f(rh)</p>
<p>    val logInfo = With(<br />
      &quot;request-uri&quot; -&gt; rh.uri,<br />
      &quot;request-time&quot; -&gt; (System.currentTimeMillis() - start)<br />
    )</p>
<p>    val compound = logInfo and With(&quot;date&quot; -&gt; &quot;bar&quot;)</p>
<p>    logger.info(&quot;handled&quot;, compound)</p>
<p>    result<br />
  }<br />
}<br />
[/scala]</p>
<p>Basically this creates a "With" object that is composable with other "with" objects which takes in a variable list of tuples and internally stores them as a map.</p>
<p>The factory function "Log" just instantiates the initial context object for tracking of state and captures the scala Play! logger to pass in</p>
<p>[scala]<br />
object Log {<br />
  def apply(src : Class[_]) = new Log(Logger(src))<br />
}</p>
<p>class LogData(data: Map[String, String]) {</p>
<p>  protected val logMap = data</p>
<p>  def asLog = logMap.foldLeft(&quot;&quot;)((acc, kv) =&gt; acc + kv._1 + &quot;=&quot; + kv._2 + &quot;; &quot;).trim.stripSuffix(&quot;;&quot;)</p>
<p>  def and(tup: (String, Any)) = {<br />
    val (x, y) = tup<br />
    new LogData(logMap.updated(x, y.toString))<br />
  }</p>
<p>  def and(other: LogData) = {<br />
    new LogData(logMap ++ other.logMap)<br />
  }<br />
}<br />
[/scala]</p>
<p>Now you should see the log wrapper. It just wraps the scala play logger and takes in an extra log data if its passed in:</p>
<p>[scala]<br />
class Log(logger: LoggerLike) {</p>
<p>  def getMessage(s: String, data: LogData): String = {<br />
    if (data != null) {<br />
      return s + &quot; &quot; + data.asLog<br />
    }</p>
<p>    s<br />
  }</p>
<p>  def info(s: String, m: LogData = null, t: Throwable = null) = logger.info(getMessage(s, m), t)</p>
<p>  def debug(s: String, m: LogData = null, t: Throwable = null) = logger.debug(getMessage(s, m), t)</p>
<p>  def warn(s: String, m: LogData = null, t: Throwable = null) = logger.warn(getMessage(s, m), t)</p>
<p>  def error(s: String, m: LogData = null, t: Throwable = null) = logger.error(getMessage(s, m))</p>
<p>}<br />
[/scala]</p>
<p>At this point we just need to create the with context class, which again is just a factory function for the LogData class</p>
<p>[scala]<br />
object With {<br />
  def apply(tup: (String, Any)*) = {<br />
    new LogData(tup.map(i =&gt; (i._1, i._2.toString)).toMap)<br />
  }<br />
}<br />
[/scala]</p>
<p>Since the main logger takes LogData instances this kind of works out well</p>
<p>Now we can get nicely uniform formatted messages for easy parsing in utilities like Splunk</p>
