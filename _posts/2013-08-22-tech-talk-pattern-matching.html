---
layout: post
title: 'Tech talk: Pattern matching'
date: 2013-08-22 16:00:40.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Tech talks
tags:
- F#
- pattern matching
- tech talk
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  _su_rich_snippet_type: none
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1560233663;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:3565;}i:1;a:1:{s:2:"id";i:4961;}i:2;a:1:{s:2:"id";i:4881;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2013/08/22/tech-talk-pattern-matching/"
---
<p>Today's tech talk was about functional pattern matching.  This was a really fun one since I've been sort of "evangelizing" functional programming at work, and it was a blast seeing everyone ask poignant and intersting questions regarding pattern matching.  </p>
<p>What spurred the conversation today was a question my boss asked me which was "how is pattern matching actually compiled?" which led me to find <a href="http://www.codeproject.com/Articles/520869/A-Simple-Overview-on-How-Pattern-Match-Compiles" target="_blank" rel="noopener noreferrer">this blog post</a> describing different ways the f# compiler compiles pattern matching.  The short of it is that the compiler generates a souped up switch statement where it checks each pattern in order. Sometimes it does a good job, sometimes it doesn't, but that's OK.</p>
<p>In the process of researching for the tech talk I came across a great paper entitled <a href="http://wiki.ifs.hsr.ch/SemProgAnTr/files/PatternMatchingInScala.pdf" target="_blank" rel="noopener noreferrer">Pattern Matching in Scala</a> which discussed, obviously, pattern matching in Scala, but also talked about F#, Haskell, and Erlang pattern matching. The interesting thing to me here is how Scala got around comparing classes instead of just algebraic data types.  Scala makes you implement classes as specific <code>case</code> classes when you want to be able to match on them, and also you have to implement <code>apply</code> and <code>unapply</code> methods which effectively "box" and "unbox" your pattern.  </p>
<p>I don't have much experience with Scala (I skimmed a Scala book and wrote a hello world, but that's it), but I am familiar with how F# handled this scenario which is via Active Patterns. I like this since you can mix and match active patterns to provide your own custom way to "compare" items.  </p>
<p>An example I used in our talk today was</p>
<p>[fsharp]<br />
let (|Pattern1|_|) i =<br />
    if i = 0 then Some(Pattern1) else None</p>
<p>let (|Pattern2|_|) i =<br />
    if i.ToString() = &quot;yo mamma!&quot; then Some(Pattern2) else None</p>
<p>let activePatternTest () =<br />
    let x = 0<br />
    match x with<br />
        | Pattern1 -&gt; printf &quot;pattern1&quot;<br />
        | Pattern2 -&gt; printf &quot;pattern2&quot;<br />
        | _ -&gt; printf &quot;something else&quot;<br />
[/fsharp]</p>
<p>Which really drives the point home that you can do custom work in your pattern match and hide it away from the user. Another, more real world, example is how I matched on regular expressions in my <a href="https://github.com/devshorts/ParsecClone" target="_blank" rel="noopener noreferrer">parsec clone</a> project</p>
<p>[fsharp]<br />
let (|RegexStr|_|) (pattern:string) (input:IStreamP&lt;string, string&gt;) =<br />
        if String.IsNullOrEmpty input.state then None<br />
        else<br />
            let m = Regex.Match(input.state, &quot;^(&quot; + pattern + &quot;)&quot;, RegexOptions.Singleline)<br />
            if m.Success then<br />
                Some ([ for g in m.Groups -&gt; g.Value ]<br />
                            |&gt; List.filter (String.IsNullOrEmpty &gt;&gt; not)<br />
                            |&gt; List.head)<br />
            else<br />
                None<br />
[/fsharp]</p>
<p>Which can be used to hide away regular expression pattern matching.  The usage of this would now be:</p>
<p>[fsharp]<br />
member x.regexMatch (input:IStreamP&lt;string, string&gt;) target =<br />
        if String.IsNullOrEmpty input.state then None<br />
        else<br />
            match input with<br />
                | RegexStr target result -&gt; Some(result.Length)<br />
                | _ -&gt; None<br />
[/fsharp]</p>
<p>Nice and clean, just the way I like it.</p>
<p>Anyways, pattern matching is a really powerful construct and it's a shame that it's not available in many OO languages.  </p>
