---
layout: post
title: Plugin class loaders are hard
date: 2015-12-12 01:31:34.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- asm
- classloader
- java
- osgi
- plugin
- runtime
meta:
  _edit_last: '1'
  _syntaxhighlighter_encoded: '1'
  _su_rich_snippet_type: none
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1561588999;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:4844;}i:1;a:1:{s:2:"id";i:4306;}i:2;a:1:{s:2:"id";i:4699;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2015/12/12/class-loaders-hard/"
---
<p>Plugin based systems are really common. Jenkins, Jira, wordpress, whatever.  Recently I built a plugin workflow for a system at work and have been mired in the joys of the class loader. For the uninitiated, a class in Java is identified uniquely by the class loader instance it is created from as well as its fully qualified class name. This means that <code>foo.bar</code> class loaded by class loader A is <em>not the same</em> as <code>foo.bar</code> class loaded by class loader B.  </p>
<p>There are actually some cool things you can do with this, especially in terms of code isolation. Imagine your plugins are bundled as shaded jars that contain all the internal dependencies. By leveraging class loaders you can isolate potentially conflicting versions of libraries from the host application and the plugin.  But, in order to communicate to the host layer, you need a strict set of shared interfaces that the host layer always owns.  When building the uber jar you exclude the host interfaces from being bundled (and all its transitive dependencies which in maven can be done by using scope <code>provided</code>). This means that they will always be loaded by the host.</p>
<p>In general, class loaders are heirarchical. They ask their parent if a class has been loaded, and if so returns that. In order to do plugins you need to invert that process. First look inside the uber-jar, and then if you can't find a class then look up. </p>
<p>An example can be found <a href="http://tech.puredanger.com/2006/11/09/classloader/">here</a> and copied for the sake of internet completeness:</p>
<p>[java]<br />
import java.net.URL;<br />
import java.net.URLClassLoader;<br />
import java.net.URLStreamHandlerFactory;<br />
import java.util.UUID;</p>
<p>public class PostDelegationClassLoader extends URLClassLoader {</p>
<p>    private final UUID id = UUID.randomUUID();</p>
<p>    public PostDelegationClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory) {<br />
        super(urls, parent, factory);<br />
    }</p>
<p>    public PostDelegationClassLoader(URL[] urls, ClassLoader parent) {<br />
        super(urls, parent);<br />
    }</p>
<p>    public PostDelegationClassLoader(URL[] urls) {<br />
        super(urls);<br />
    }</p>
<p>    public PostDelegationClassLoader() {<br />
        super(new URL[0]);<br />
    }</p>
<p>    @Override<br />
    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {<br />
        try (ThreadCurrentClassLoaderCapture capture = new ThreadCurrentClassLoaderCapture(this)) {<br />
            Class loadedClass = findLoadedClass(name);</p>
<p>            // Nope, try to load it<br />
            if (loadedClass == null) {<br />
                try {<br />
                    // Ignore parent delegation and just try to load locally<br />
                    loadedClass = findClass(name);<br />
                }<br />
                catch (ClassNotFoundException e) {<br />
                    // Swallow - does not exist locally<br />
                }</p>
<p>                // If not found, just use the standard URLClassLoader (which follows normal parent delegation)<br />
                if (loadedClass == null) {<br />
                    // throws ClassNotFoundException if not found in delegation hierarchy at all<br />
                    loadedClass = super.loadClass(name);<br />
                }<br />
            }<br />
            return loadedClass;<br />
        }<br />
    }</p>
<p>    @Override<br />
    public URL getResource(final String name) {<br />
        final URL resource = findResource(name);</p>
<p>        if (resource != null) {<br />
            return resource;<br />
        }</p>
<p>        return super.getResource(name);<br />
    }<br />
}<br />
[/java]</p>
<p>But this is just the tip of the fun iceberg. If all your libraries play nice then you may not notice anything. But I recently noticed using the apache xml-rpc library that I would get a SAXParserFactory class def not found exception, specifically bitching about instantiating the sax parser factory. I'm not the only one apparenlty, <a href="https://answers.atlassian.com/questions/104121/im-blocked-help-cannot-be-cast-to-javax.xml.parsers.saxparserfactory">here is a discussion</a> about a JIRA plugin that wasn't happy. After much code digging I found that the classloader being used was the one bound to the threads current context.</p>
<p>Why in the world is there a classloader bound to thread local? JavaWorld has a <a href="http://www.javaworld.com/article/2077344/core-java/find-a-way-out-of-the-classloader-maze.html:">nice blurb</a> about this </p>
<blockquote><p>Why do thread context classloaders exist in the first place? They were introduced in J2SE without much fanfare. A certain lack of proper guidance and documentation from Sun Microsystems likely explains why many developers find them confusing.</p>
<p>In truth, context classloaders provide a back door around the classloading delegation scheme also introduced in J2SE. Normally, all classloaders in a JVM are organized in a hierarchy such that every classloader (except for the primordial classloader that bootstraps the entire JVM) has a single parent. When asked to load a class, every compliant classloader is expected to delegate loading to its parent first and attempt to define the class only if the parent fails.</p>
<p>Sometimes this orderly arrangement does not work, usually when some JVM core code must dynamically load resources provided by application developers. Take JNDI for instance: its guts are implemented by bootstrap classes in rt.jar (starting with J2SE 1.3), but these core JNDI classes may load JNDI providers implemented by independent vendors and potentially deployed in the application's -classpath. This scenario calls for a parent classloader (the primordial one in this case) to load a class visible to one of its child classloaders (the system one, for example). Normal J2SE delegation does not work, and the workaround is to make the core JNDI classes use thread context loaders, thus effectively "tunneling" through the classloader hierarchy in the direction opposite to the proper delegation. </p></blockquote>
<p>This means that whenever I'm delegating work to my plugins I need to be smart about capturing my custom plugin class loader and putting it on the current thread before execution. Otherwise if a misbehaving library accesses the thread classloader, it can now have access to the ambient root class loader and IFF the same class name exists in the host application it will load it. This could potentially conflict with other classes from the same package that aren't loaded this way and in general cause mayhem.</p>
<p>The solution here was a simple class modeled after .NET's disposable pattern using Java's try/finally auto closeable.</p>
<p>[java]<br />
public class ThreadCurrentClassLoaderCapture implements AutoCloseable {<br />
    final ClassLoader originalClassLoader;</p>
<p>    public ThreadCurrentClassLoaderCapture(final ClassLoader newClassLoader) {<br />
        originalClassLoader = Thread.currentThread().getContextClassLoader();</p>
<p>        Thread.currentThread().setContextClassLoader(newClassLoader);<br />
    }</p>
<p>    @Override<br />
    public void close() {<br />
        Thread.currentThread().setContextClassLoader(originalClassLoader);<br />
    }<br />
}<br />
[/java]</p>
<p>Which is used before each and every invocation into the interface of the plugin (where <code>connection</code> is the plugin reference)</p>
<p>[java]<br />
@Override<br />
public void start() throws Exception {<br />
    captureClassLoader(connection::start);<br />
}</p>
<p>@Override<br />
public void stop() throws Exception {<br />
    captureClassLoader(connection::stop);<br />
}</p>
<p>@Override<br />
public void heartbeat() throws Exception {<br />
    captureClassLoader(connection::heartbeat);<br />
}</p>
<p>private void captureClassLoader(ExceptionRunnable runner) throws Exception {<br />
    try (ThreadCurrentClassLoaderCapture capture = new ThreadCurrentClassLoaderCapture(connection.getClass().getClassLoader())) {<br />
        runner.run();<br />
    }<br />
}<br />
[/java]</p>
<p>However, this isn't the only issue.  Imagine a scenario where you support both class path loaded plugins AND remote loaded plugins (via shaded uber-jar). And lets pretend that on the classpath is a jar with the same namespaces and classes as that in an uberjar. To be more succinct, you have a delay loaded shared library on the class path, and a version of that library that is shaded loaded via the plugin mechanism.</p>
<p>Technically there shouldn't be any issues here.  The class path plugin gets all its classes resolved from the root scope. The plugin gets its classes (of the same name) from the delegated provider.  Both use the same shared set of interfaces of the host. The issue arrises if you have a library like reflectasm, which dynamically emits bytecode at runtime.  </p>
<p>Look at this code:</p>
<p>[java]<br />
AccessClassLoader loader = AccessClassLoader.get(type);<br />
synchronized (loader) {<br />
	try {<br />
		accessClass = loader.loadClass(accessClassName);<br />
	} catch (ClassNotFoundException ignored) {<br />
		String accessClassNameInternal = accessClassName.replace('.', '/');<br />
		String classNameInternal = className.replace('.', '/');<br />
		ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);<br />
[/java]</p>
<p>Which is a snippet from reflectasm as its generating a runtime byte code emitter that can access fields for you.  It creates a class name like <code>your.class.nameMethodAccess</code>. If the class name isn't found, it generates the bytecode and then writes it into the owning classes class loader.</p>
<p>In the scenario of a plugin using this library, it will check the loader and see that the plugin classloader AND rootscope loader do not have the emitted class name, and so a class not found exception is thrown. It will then write the class into the <em>target types class loader</em>. This would be the delegated loader, and provides the isolation we want.</p>
<p>However, if the class path plugin (what I call an embedded plugin) runs this code, the dynamic runtime class is written into the <em>root scope</em> loader.  This means that all delegating class loaders will eventually find this type since they always do a delegated pass to the root!</p>
<p>The important thing to note here is that using a delegated loader does not mean every class that comes out of it is tied to the delegated loader. Only classes that are found inside of the delegated loader are bound to it. If a class is resolved by the parent, the class is linked to the parent. </p>
<p>In this scenario with the root class loader being polluted with the same class name, I don't think there is much you can do other than avoid it.</p>
<p>Anyways, maybe I should have used OSGi...?</p>
