---
layout: post
title: Building LINQ in Java
date: 2013-12-30 08:00:34.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- iterator
- java
- lambda
- lazy
- linq
meta:
  _edit_last: '1'
  _su_rich_snippet_type: none
  _syntaxhighlighter_encoded: '1'
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1559686498;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:4306;}i:1;a:1:{s:2:"id";i:4355;}i:2;a:1:{s:2:"id";i:4862;}}}}
author:
  login: akropp
  email: akropp@gmail.com
  display_name: akropp
  first_name: ''
  last_name: ''
permalink: "/2013/12/30/building-linq-java/"
---
<p>Now that Java 8 has lambdas, I decided to check out what kind of lazy collection support their streams functionality had.  It had some cool stuff, like </p>
<ul>
<li>map</li>
<li>filter</li>
<li>flatMap</li>
<li>distinct</li>
<li>sorted</li>
<li>limit (i.e. take)</li>
<li>skip</li>
<li>reduce (i.e fold)</li>
<li>min</li>
<li>max</li>
<li>any</li>
<li>all</li>
<li>generate (for building infinite lists)</li>
</ul>
<p>Not too bad.  But, there are some problems, as far as I see it.  First, you can't extend it. With .NET they solved the lambda problem with extension methods, but Java oddly chose "defender" methods, which lets you safely update an interface declaration, but ONLY the author can do it, not any consumer.  That sucks.  I want other fun functions like </p>
<ul>
<li>first</li>
<li>last</li>
<li>nth</li>
<li>windowed</li>
<li>intersperse</li>
<li>intercalate</li>
<li>tails</li>
<li>intersect</li>
<li>zip</li>
<li>groupRuns</li>
</ul>
<p>And pretty much any other F#/Haskell list function. Why not? If we're going to go with lazy evaluated lists we might as well have all the fun that comes with them.  There is another problem with the Java 8 streams API, unless I'm mistaken, there is no way to <em>end</em> an infinite stream generated using the <code>generate</code> function.  That really sucks since not every lazy generated stream is infinite. </p>
<p>So, I decided to try my hand and rebuilding LINQ in Java 8.  For the impatient, the full source, tests, and benchmarks are available at my <a href="https://github.com/devshorts/JEnumerable" target="_blank" rel="noopener noreferrer">github</a>.</p>
<h2>Iterator chains</h2>
<p>The basic idea here is to create an iterator for each type of processing you want to do. If you want to do a map function, you should create an iterator that wraps a source. When the iterator consumes from the underlying source it will emit a projected element.  How do you do this? Well, you can use a fluent API that returns a new enumerable class that wraps a specific iterator.  For example</p>
<p>[java]<br />
private Function&lt;Iterable&lt;TSource&gt;, Iterator&lt;TSource&gt;&gt; iteratorGenerator;</p>
<p>public static &lt;TSource&gt; Enumerable&lt;TSource&gt; init(Iterable&lt;TSource&gt; source){<br />
    return new Enumerable&lt;&gt;(_ig -&gt; new EnumerableIterator&lt;&gt;(source));<br />
}                                                                          </p>
<p>protected Enumerable(Function&lt;Iterable&lt;TSource&gt;, Iterator&lt;TSource&gt;&gt; iteratorGenerator) {<br />
    this.iteratorGenerator = iteratorGenerator;<br />
}                                                                                       </p>
<p>@Override<br />
public Iterator&lt;TSource&gt; iterator() {<br />
    return iteratorGenerator.apply(this);<br />
}                                        </p>
<p>// The underlying iterator</p>
<p>public class EnumerableIterator&lt;TSource&gt; implements Iterator&lt;TSource&gt; {<br />
    protected Iterator&lt;TSource&gt; source;<br />
    private Iterable&lt;TSource&gt; input;</p>
<p>    public EnumerableIterator(Iterable&lt;TSource&gt; input){<br />
        this.input = input;</p>
<p>        reset();<br />
    }</p>
<p>    protected void reset(){<br />
        source = input.iterator();<br />
    }</p>
<p>    @Override<br />
    public boolean hasNext() {<br />
        return source.hasNext();<br />
    }</p>
<p>    @Override<br />
    public TSource next() {<br />
        return (TSource)source.next();<br />
    }<br />
}<br />
[/java]</p>
<p>Lets first look at the underlying iterator. It does nothing other than iterate over the source. That's pretty simple.  </p>
<p>The thing that wraps it is a <code>Enumerable</code> class that takes a function that, when given an Iterable, returns a new iterator.  Then it just exposes that iterator.  In general, thats the whole thing.  The iterator is wrapped in a function so that we can request a new iterator each time someone tries to iterate over this enumerable. That matches what .NET does; if someone tries to re-iterate an enumerable you get a new iterator and start over. </p>
<h2>Take</h2>
<p>Let's look at a simple iterator that takes only N elements.</p>
<p>[java]<br />
public class TakeIterator&lt;TSource&gt; extends EnumerableIterator&lt;TSource&gt; {<br />
    private int takeNum;</p>
<p>    public TakeIterator(Iterable&lt;TSource&gt; results, int n) {<br />
        super(results);<br />
        takeNum = n;<br />
    }</p>
<p>    @Override<br />
    public boolean hasNext() {<br />
        return source.hasNext() &amp;&amp; takeNum &gt; 0;<br />
    }</p>
<p>    @Override<br />
    public TSource next(){<br />
        takeNum--;<br />
        return source.next();<br />
    }<br />
}<br />
[/java]</p>
<p>And to create an instance of enumerable that uses this</p>
<p>[java]<br />
public Enumerable&lt;TSource&gt; take(int n){<br />
    return enumerableWithIterator(source -&gt; new TakeIterator&lt;&gt;(source, n));<br />
}                                                                          </p>
<p>private &lt;TResult&gt; Enumerable&lt;TResult&gt; enumerableWithIterator(Function&lt;Iterable&lt;TSource&gt;, Iterator&lt;TResult&gt;&gt; generator){<br />
    return new Enumerable&lt;&gt;(_ig -&gt; generator.apply(this));<br />
}<br />
[/java]</p>
<p>Basically I return a new enumerable with a lazy evaluated function that gives the iterator its underlying Iterator source.  By returning a new enumerable each time we can effectively chain the iterators together. Nothing is evaluated until someone tries to get the next value.  </p>
